# 交换机远程批量配置

## 几个方案
1. ansible-playbook + jinja2 + python
2. ansible + python
3. 纯python 
4. python+ netmiko库

前面三种方式都试了一下，出了第三种有点麻烦以外，1、2两个都不能使用
其中对于HP-Comware 7(我所使用的是h3c)来说，没有靠谱的ansible 模块 ,如果强行要用，那只能自己写ansible的模块了

纯python来说的话 主要是使用上传工具 将内容上传到交换机上，然后用交换机上的python模块执行python文件

## netmiko库
- 库地址
https://github.com/ktbyers/netmiko
- 该库所支持的交换机类型
https://github.com/ktbyers/netmiko/blob/master/netmiko/ssh_dispatcher.py
- 该库介绍
https://pynet.twb-tech.com/blog/automation/netmiko.html
 成功建立与设备的SSH连接
 简化show命令的执行和输出数据的检索
 简化配置命令的执行，包括可能的提交操作
 在广泛的网络供应商和平台上执行上述操作
 创建Netmiko的目的是简化各种网络供应商和平台之间的此较低级SSH管理。



## 简单连接
```bash
from netmiko import Netmiko
# 获取设备句柄
from netmiko import ConnectHandler
# 获取密码
from  getpass import  getpass

h3c_switch = {
    'device_type' : 'hp_comware',
    'host':   '10.0.5.124',
    'username': 'root',
    'password': 'upyun123',
}

# 实例化连接
net_connect = ConnectHandler(**h3c_switch)

# output = net_connect.send_command("dis int brief",delay_factor=2)
output = net_connect.send_config_from_file("task.txt")
print(output)
# print(net_connect.find_prompt())
# net_connect.disconnect()

```

## 批量控制交换机
```bash
#!/usr/bin/env python
from netmiko import Netmiko
from getpass import getpass

password = getpass()

cisco1 = {
    "host": "cisco1.twb-tech.com",
    "username": "pyclass",
    "password": password,
    "device_type": "cisco_ios",
}

cisco2 = {
    "host": "cisco2.twb-tech.com",
    "username": "pyclass",
    "password": password,
    "device_type": "cisco_ios",
}

nxos1 = {
    "host": "nxos1.twb-tech.com",
    "username": "pyclass",
    "password": password,
    "device_type": "cisco_nxos",
}

srx1 = {
    "host": "srx1.twb-tech.com",
    "username": "pyclass",
    "password": password,
    "device_type": "juniper_junos",
}

for device in (cisco1, cisco2, nxos1, srx1):
    net_connect = Netmiko(**device)
    print(net_connect.find_prompt()) 
```

## 代理连接
```bash
#!/usr/bin/env python
from netmiko import Netmiko
from getpass import getpass

key_file = "/home/gituser/.ssh/test_rsa"

cisco1 = {
    "device_type": "cisco_ios",
    "host": "cisco1.twb-tech.com",
    "username": "testuser",
    "use_keys": True,
    "key_file": key_file,
    "ssh_config_file": "./ssh_config",
}

net_connect = Netmiko(**cisco1)
print(net_connect.find_prompt())
output = net_connect.send_command("show ip arp")
print(output) 
```


## 线程连接
```bash
#!/usr/bin/env python
import threading
from datetime import datetime
from netmiko import ConnectHandler
from my_devices import device_list as devices


def show_version(a_device):
    """Execute show version command using Netmiko."""
    remote_conn = ConnectHandler(**a_device)
    print()
    print("#" * 80)
    print(remote_conn.send_command_expect("show version"))
    print("#" * 80)
    print()


def main():
    """
    Use threads and Netmiko to connect to each of the devices. Execute
    'show version' on each device. Record the amount of time required to do this.
    """
    start_time = datetime.now()

    for a_device in devices:
        my_thread = threading.Thread(target=show_version, args=(a_device,))
        my_thread.start()

    main_thread = threading.currentThread()
    for some_thread in threading.enumerate():
        if some_thread != main_thread:
            print(some_thread)
            some_thread.join()

    print("\nElapsed time: " + str(datetime.now() - start_time))


if __name__ == "__main__":
    main()c 
```

## 指令
```bash
net_connect = xxx

# 发送单条指令
net_connect.send_command("dis int brief",delay_factor=2)

# 发送多条指令
config_commands = [ 'logging buffered 20000',
                    'logging buffered 20010',
                    'no logging console' ]
output = net_connect.send_config_set(config_commands)

# 指定配置文件发送指令
/task.txt
int vlan-interface 40
ip address 172.168.20.1 30

output = net_connect.send_config_from_file("task.txt")


# 关闭连接
net_connect.disconnect()

# -将配置命令发送到远程设备
net_connect.send_config_set()

# 返回当前路由器提示
net_connect.find_prompt()
```