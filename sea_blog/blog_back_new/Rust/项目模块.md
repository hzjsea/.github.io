---
title: 项目模块
date: 2021-03-15 16:00:13
categories:  [rust]
tags: [rust]
---


<!--more-->


# 项目模块
项目模块只要是来管理项目，将项目中可共享的模块区分开来。


## 模块管理
可以先看下面的项目
Rust的模块就是命名空间，用关键词mod表示。它的作用是把一个crate的代码划分成可管理的部分。每一个crate都有一个顶层的匿名根命名空间, 根空间下面的命名空间可以任意嵌套，这样构成一个树形结构

```rust
// good_bye/src/lib.rs
pub fn say(){
    println!("good bye")    
}


pub mod xxer{
    fn echo(){
        println!("echo")
    }

    pub fn echo_pub(){
        echo()
    }
}
```

```rust
// main.rs
extern crate good_bye;
fn main() {
    println!("Hello, world!");
    good_bye::say();
    good_bye::xxer::echo_pub();
    good_bye::xxer::echo(); // error , because not public
}
```

### mod分层

> 把多个模块写到一个文件下面

```rust
// lib.rs
mod caller {
    fn call() {}
}
mod worker {
    fn work1() {}
    fn work2() {}
    fn work3() {}
}
```

> 把多个模块写到多个文件下面

```rust
// <lib.rs>
mod caller;
mod worker;
// <caller.rs>
fn call() {}// <worker.rs>
fn work1() {}
fn work2() {}
fn work3() {}
```

> 把多个模块写到多个文件夹下面

```rust
// <lib.rs>
mod caller;
mod worker;
// <caller.rs>
fn call() {}
// <worker/mod.rs>
mod worker1;
mod worker2;
mod worker3;
// <worker/worker1.rs>
fn work1() {}
// <worker/worker2.rs>
fn work2() {}
// <worker/worker3.rs>
fn work3() {}
```

### 私有与占有
rust中的引用只要路劲可达，就可以使用，一个mod下面有多个方法， 假设这个mod下面的所有的方法都是public,但是mod是私有的，则路径不可达，不能使用



## 小项目案例
rust中有两个项目结构有两个概念，一个是create,另一个是mod,一个create是一个完整的编译单元，
mod之间可以互相调用方法，crate之间不能出现循环引用

创建一个工程文件夹
```bash
# 创建项目
mkdir workspace
# 创建工程文件 --bin 创建的是main.rs --lib 创建的是lib.rs
cargo new helloworld --bin
cargo new goodbye --lib
```
看下目录结构
```bash
🏃:rust/ $ tree  -L 3
.
├── goodbye   # 本地包
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
└── helloworld  # 项目主文件夹
    ├── Cargo.lock
    ├── Cargo.toml
    ├── src
    │   └── main.rs
    └── target
        ├── debug
        └── rls
```

编写本地包中的内容
```rust
// 在goodbye/src/lib下面写上如下代码
pub fn say(){
    println!("good bye")    
}
```
在主包helloworld中调用
```rust
// helloworld/Cargo.toml

[dependencies]
goodbye = { path = "../goodbye"}

// helloworld/src/main.rs
extern crate goodbye;
fn main(){
    println!("helloworld");
    goodbye::say();
}
```

> 加强版
```bash
🏃:rust/ $ tree . -L 3
.
├── goodbye
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── src
│   │   └── lib.rs
│   └── target
│       ├── debug
│       └── rls
├── helloman
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── src
│   │   └── lib.rs
│   └── target
│       ├── debug
│       └── rls
├── hellowoman
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── src
│   │   └── lib.rs
│   └── target
│       └── rls
├── helloworld
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── src
│   │   └── main.rs
│   └── target
│       ├── debug
│       └── rls
```
```rust
// helloworld/Cargo.toml
[dependencies]
goodbye = { path = "../goodbye"}
helloman = { path = "../helloman"}
hellowoman = { path = "../hellowoman"}

// helloworld/main.rs
extern crate goodbye;
extern crate helloman;
extern crate hellowoman;
extern crate hellowoman as woman; // 
fn main(){
    println!("helloworld");
    goodbye::say();
    helloman::sayman();
    hellowoman::saywoman();
}
```

## 大项目案例
大项目案例中就要涉及到workspace的使用了，用第一个项目的案例
```rust
🏃:workspace/ $ ls -al
total 0
drwxr-xr-x   4 alpaca  staff  128 Mar 15 16:03 .
drwxr-xr-x  16 alpaca  staff  512 Mar 15 16:02 ..
drwxr-xr-x   8 alpaca  staff  256 Mar 15 16:03 good_bye
drwxr-xr-x   8 alpaca  staff  256 Mar 15 16:29 helloworld
🏃:workspace/ $
```
创建一个`Cargo.toml`
```rust
[workspace]
members = [
        "helloworld",
        "good_bye"
]
```
写上要编译的所有文件件，cargo build 一下会在当前文件夹产生一个target编译后的文件，以及Cargo.lock版本控制的文件
```rust
🏃:workspace/ $ ll
total 16
-rw-r--r--  1 alpaca  staff   229B Mar 15 16:37 Cargo.lock
-rw-r--r--  1 alpaca  staff    53B Mar 15 16:39 Cargo.toml
drwxr-xr-x  8 alpaca  staff   256B Mar 15 16:32 good_bye
drwxr-xr-x  8 alpaca  staff   256B Mar 15 16:29 helloworld
drwxr-xr-x  4 alpaca  staff   128B Mar 15 16:32 target
🏃:workspace/ $
```


## 包管理总结 update

rust 官方的包管理总感觉讲的有点乱，自己找了一个 github 的项目总结一下，可能有点问题，后面项目跟进的时候再看看效果

首先是创建一个项目文件夹

```bash
cargo new zz

# 项目结构如下
# alpaca:zz/ (master✗) $ tree .                                                                                    [16:21:49]
# .
# ├── Cargo.toml
# └── src
#     └── main.rs

```

创建了一个 main.rs 文件 `Cargo.toml`是一个依赖文件夹，当你想要引用第三方库的时候，就需要在 toml 中去添加依赖

接下来是包管理中的一些名词介绍

### Crate 箱根

`Crate` 每一个通过 cargo 创建的项目称之为一个 Crate，无论是以库形式(lib.rs)或者是二进制形式(main.rs)。其中唯一的 rs 文件称之为 Crate root，也叫作箱根，也是一个 Crate 的入口点，子模块的加载之类的，都在对应的箱根中有声明。 对于这个`Create`箱根 系统的标准库也有一个箱根，名为 std，我们可以直接引用该 Crate 而不必在 Cargo.toml 的依赖中添加，因为安装好 rust 之后标准库也安装好了，不必从第三方进行下载。当我们需要在自己的两个本地项目中互相引用包的时候，就需要在`Cargo.toml`中去引用

```rust
[package] 
name = "zz"   // 主项目文件
version = "0.1.0"  // 版本号
authors = ["hzjsea <hzjsea@gmail.com>"] // 作者
edition = "2018" // rust版本号

[dependencies]  // 扩展库
sep_restaurant = { path = "../sep_restaurant" }
```

如上，我们引用了一个本地的名为 `sep_restaurant` 的 Crate，而该包的路径是相对于 Cargo.toml 的。

### mod

无论是`main.rs`还是`lib.rs`，所有的 mod 都必须定义在根箱中
创建一个根箱

```bash
# alpaca:zz/ (master✗) $ ls                                                                         
# Cargo.toml src
alpaca:zz/ (master✗) $ cargo new --lib restaurant              # 创建一个扩展库                                                  
#      Created library `restaurant` package
# alpaca:zz/ (master✗) $ ls                                                                                   
# Cargo.toml restaurant src

alpaca:zz/ (master✗) $ tree .                            # 查看当前路径下的目录结构                                                        
# .
# ├── Cargo.toml
# ├── restaurant
# │   ├── Cargo.toml
# │   └── src
# │       └── lib.rs
# └── src
#     └── main.rs

# 3 directories, 4 files
```

在`lib.rs`中添加 mod

```rust
pub mod first_level_mod {
    pub fn hello() {
        println!("hello");
    }
}
```

于是目录树中的结构是这样的

```bash
# 顶层  create
# 下一层 first_level_mod   --  function : hello()
```

创建一个 sub mod

```rust
pub mod first_level_mod {
    pub fn hello() {
        println!("hello");
    }
    mod second_level_mod {
        pub fn world() {
            println!("world")
        }
    }

}
```

于是 目录树更新为

```bash
# 顶层 create
# 下一层 first_level_mod -- function : hello()
    # 下一层 second_level_mod  -- function : world()
```

### mod 与 mod 之间的层级关系

对于 mod 的整个家族来说，他有父子层级之分，对应的权限规则如下

- 父亲 也就是一级层之间的是权限是透明的
- 父亲/(儿子,儿子) 也就是同一级层下面的儿子层互相之间也是透明的
- 不同级层下面的儿子之间是不透明的

### 引用本地 create

```bash
rustmod
├── Cargo.toml
└── src
    ├── main.rs
    ├── function.rs
    └── util.rs
xxx
├── Cargo.toml
└── src
    └── lib.rs
```

修改`rustmod/Cargo.toml`

```rust
[package]
name = "testmod"
version = "0.1.0"
authors = ["Shidong Wang <wsdjeg@outlook.com>"]
edition = "2018"

[dependencies]
xxx = {path= "../xxx" }
```

在 main.rs 中引用

```rust
extern crate xxx;
use xxx::xxx_func;
fn main() {
    xxx_func();
}
```

### 同级目录相互访问

```rust
rustmod
├── Cargo.toml
└── src
    ├── main.rs
    ├── function.rs
    └── util.rs
```

```rust
// rustmod/src/function.rs
use crate::util;
fn hello_function() {
    util::hello_mod();
}
```