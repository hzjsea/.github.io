---
title: ansible基础
categories:
  - ansible
abbrlink: ea06c230
tags:
  - ansible
date: 2020-03-08 19:46:58
---

# ansible 
> Ansilbe是一个部署一群远程主机的工具,自动化运维必须掌握的基础


## 主机清单
主机清单主要用于存放ansible管理的一些机器，ansible采用了多种方法对这些机器进行整理分类
当你安装完成ansible之后，主机清单的默认文件夹在/etc/ansible/hosts中


## ansible原理
由于ansible是通过ssh访问被执行端主机的，因此没有ssh的权限是无法完成任务的，即使这里的命令是ping，但依旧要走ssh的流程
这里的ping并不是linux下的ping ,而是ansible工具下面的ping模块

### ansible命令执行流程
1. 加载自己的配置文件 默认为/etc/ansible/ansible.cfg
2. 加载自己对应的模块文件,如command
3. 通过ansible将模块或命令生成对应的临时py文件,并将文件传输至远程服务器的对应执行用户$HOME/.ansible/tmp/ansible-tmp-数字/xxx.py文件
4. 增加文件的执行权限
5. 执行并返回结果
6. 删除临时py文件,sleep 0退出
执行状态:
绿色 执行成功并且不需要做改变的操作
黄色 执行成功但是对目标主机做了修改
红色 执行失败
(颜色内容在/etc/ansible.cfg里面修改)

## ansible的两种形式
ansible面对不同的使用场景，有不同的形式
一种是ad-hoc command的形式
另一种是ansible-playbook的形式

## 使用ad-hoc command

常用的两种形式
直接在命令行中指定ip,-m 指定模块
```bash
ansible 192.168.20.1 -m ping 
ansible 192.168.20.1,192.168.20.2 -m ping 
```
使用自定义清单的形式
```bash
echo "192.168.20.1 ansible_ssh_pass=upyun123 ansible_ssh_user=root"  >> xx
ansible -i xx all -m ping -k
```

## 发送秘钥到指定机器
```bash
ssh-copy-id -i /root/.ssh/id_rsa.pub root@10.0.5.233
```
他这里会把迷钥发到对端机器上的known_hosts上面


## 配置文件 
安装完成ansible后，在/etc/ansible 下面会有如下几个文件
```bash 
total 24
-rw-r--r--. 1 root root 19179 Jan 30  2018 ansible.cfg
-rw-r--r--. 1 root root  1016 Jan 30  2018 hosts
drwxr-xr-x. 2 root root     6 Jan 30  2018 roles
```

- `/etc/ansible/ansible.cfg` 配置文件
```bash
local_tmp是本地的执行指令
remote_tmp是远程的执行指令
当用户使用ansible控制被控端执行指令的时候，他会先将内容放在local_tmp文件中，然后上传到被控端并生成remote_tmp上执行。执行完成之后会删除这两个tmp文件
library = /usr/share/my_modules/ 库存放地址
forks = 5 默认并发数
sudo_user = root 默认sudo 用户
ask_sudo_pass = True  每次执行ansible是否询问ssh密码
ask_pass = True
remote_port = 22
host_key_checking = False 检查对应服务器的host_key ----->建议取消注释
```
- `/etc/ansible/roles` 存放角色的地方，跟ansible-playbook有关
- `/etc/ansible/hosts` 主机清单，也可以自定义文件，用`-i` 指定就行了

## 主机清单
同上所讲，主机清单可以使用ansible自带的，也可以使用自己创建，在命令行中使用-i指定
主机清单写法
```bash
# 单台机器
mail.example.com
# 声明端口
mail.example1.com:5506
mail.example2.com ansible_ssh_port=2206
# 分组
[webservers]
foo.example.com
bar.example.com
[dbservers]
one.example.com
two.example.com
three.example.com

# 声明用户 密码 连接方式 指定秘药 别名 
mail.example3.com ansible_ssh_user=root ansible_ssh_pass=passwd ansible_connection=ssh ansible_ssh_private_key_file="~/.ssh/id_rsa"

# 把一个组作为另外一个组的成员
[atlanta]
host1
host2
[raleigh]
host2
host3
[southeast:children]
atlanta
raleigh
[southeast:vars]
some_server=foo.southeast.example.com
halon_system_timeout=30
self_destruct_countdown=60
escape_pods=2
[usa:children]
southeast
northeast
southwest
northwest
```

## 命令 

### ansible-doc 说明文档
ansible-doc [options] [module..]
-a 显示所有模块的文档 参数尽量放在单引号里面
-l --list 列出可用模块
-s --snippet xxx 显示xxx模块的playbook片段

### ansible命令
```bash 
# 列出指定组别的host列表
ansible appsevr --list-hosts
# 列出所有列表的host
ansible -i xx  all --list-hosts
ansible -i xx  all --list
# 支持通配符匹配host
ansible *serv --list
# 多批量执行
ansible 192.168.0.1,192.168.0.2 -m ping
# 多组别批量执行(逻辑或关系,合并，A和B所有)
ansible websevr:appsevr -m ping      
(逻辑与关系,区分,在A中,也在B中)
# ansible "websevr:&appsevr" -m ping
(逻辑非,在A中不在B中,此处必须要用单引号)
# ansible 'websevr:!appsevr' -m ping 

ansible <host-pattern> [-m module_name] [-a args]
--version 显示版本
-m module 指定模板,默认为command
-v 详细过程 -vv -vvv更详细
--list --list-hosts 显示主机列表，
-k --ask-pass 提示输入ssh连接密码，默认为key验证
-K --ask-become-pass 提示输入sudo时的口令
-C --check 检查，并不执行
-T --timeout=TIMEOUT 执行命令的超时时间,默认为10s
-u --user=REMOTE_USER 执行远程执行的用户
-b --become 代替旧版的sudo切换 (默认为ansible.cfg里面设置的用户,一般为root)
-a 指定参数 
```



## 模块
由于Ansible的模块过多，将近有1378个模块数量,但是每个模块的介绍以及使用方法都存放在/usr/bin/ansible-doc当中
```bash
# 查看当前ansible模块
ansible-doc -l 
# ansible-doc的使用方法
ansible-doc [options] [module..]
-a 显示所有模块的文档 参数尽量放在单引号里面
-l --list 列出可用模块
-s --snippet xxx 显示xxx模块的playbook片段
ansible -m command # 使用-m指定模块，默认为command
# 查看模块使用方法
ansible-doc -s git
```

### command
在command中,我们可以创建文件，但是对于文件的操作,有一个专门的file模块
```bash
# 创建一个文件
ansible -m command -a 'mkdir \data'
# 查看文件是否创建成功
ansible -m command -a 'ls -al \data'
# 查看command帮助
ansible-doc command
```

### shell
如果-a 后带的参数中出现 $ < > | ;  & 等字符，command是不支持的，需要用到shell 模块
```bash
# 输出主机名字
ansible 192.168.1.3 -m shell -a 'echo $HOSTNAME'  
```

### script
既然ansible可以对多台主机进行批量的操作，那往往我们会遇到一个场景，即需要我们在多台主机上执行一个脚本，这个场景下我们有两个方法:
1.将脚本文件复制到多台主机上后,调用ansible使用
2.使用script模块，仅在控制端存在脚本文件即可
```bash
# 方法一,先将文件发到对应控制端主机
ansible 192.168.1.3 -m command -a '/root/ansible_test.sh'
# 方法二
root@DESKTOP-GT1K5L0:~# ansible 192.168.1.3 -m script -a '/root/ansible_test.sh'
192.168.1.3 | SUCCESS => {
    "changed": true,
    "rc": 0,
    "stderr": "Shared connection to 192.168.1.3 closed",
    "stdout": "to do it,ansible",
    "stdout_lines": [
        "to do it,ansible"
    ]
} 
```


### Copy
- fetch模块是将远程主机拉取文件到本地
- copy是将本地文件复制到远程主机

#### 参数列表


在上面我们提到了从控制端传输文件到被控端,既然是批量的操作,那么在ansible中同样存在一个copy的模块,可以用来传输文件
场景: 关闭多台主机的selinux 
流程: 复制控制端selinux的配置文件，修改后发送到被控制端

注意:这里的ho表示的是一个主机群 在/etc/ansible/hosts中已经添加了

```bash
# 查看控制端selinux状态
getenforce

# 查看被控端selinux状态
[root@localhost ~]# ansible ho -m command -a 'getenforce'
192.168.1.6 | SUCCESS | rc=0 >>
Enforcing
192.168.1.7 | SUCCESS | rc=0 >>
Enforcing
192.168.1.5 | SUCCESS | rc=0 >>
Enforcing
192.168.1.4 | SUCCESS | rc=0 >>
Enforcing

# 复制selinux配置文件，并修改配置
cp /etc/selinux/config  .
SELINUX=disabled

# 复制配置文件到被控端指定路径,并做好备份
ansible ho -m copy -a'src=/root/hzj/config dest=/etc/selinux/config backup=yes'

# 查看被控端是否生成备份文件
ansible ho -m command -a 'ls /etc/selinux/'

# 重启
ansible ho -m command -a 'reboot'
# 查看被控端selinux是否修改完成
ansible ho -m command -a 'getenforce'
[root@localhost hzj]# ansible ho -m command -a 'getenforce'
192.168.1.7 | SUCCESS | rc=0 >>
Disabled
192.168.1.4 | SUCCESS | rc=0 >>
Disabled
192.168.1.5 | SUCCESS | rc=0 >>
Disabled
192.168.1.6 | SUCCESS | rc=0 >>
Disabled
```

### fetch
ansible支持从被控端抓取文件到控制端,抓取后的格式为\example.com\dest
src表示抓取路径
dest表示存放路径
```bash
# 复制所有主机的日志到控制端
ansible ho -m fetch -a 'src=/var/log/messages dest=/root/data'
```
但是fetch仅支持单个文件的抓取，当我们想要抓取多个日志文件时，可以先进行打包


### file
创建文件
```bash
# 创建文件
ansible ho -m file -a 'name=/data/f3 state=touch'
# 删除文件
ansible ho -m file -a 'name=/data/f3 state=absent'
# 创建文件夹
ansible ho -m file -a 'name=/data/f3 state=directory'
# 删除文件夹
ansible ho -m file -a 'name=/data/f3 state=absent'
# 创建软连接
ansible ho -m file -a 'src=/root/test name=/data/fq state=link'

# 但是需要注意的是如果你创建了文件f3 当你创建文件夹f3的时候会出现错误
```

### hostname
修改主机名
```bash
ansible ho -m hostname -a 'name=node'
# 重启后生效
```

### cron
```bash
# 给每台主机添加任务,name为注释
ansible ho -m cron -a 'minute=* weekday=1,3,5,7 job="usr/bin/wall message"  name=test'
# 取消任务
ansible ho -m cron -a 'disabled=true job="usr/bin/wall message" name=test'
# 重新启用
ansible ho -m cron -a 'disabled=no job="usr/bin/wall message" name=test'
# 删除某条任务
ansible ho -m corn -a 'jon="usr/bin/wall message" state=absent'
```

### yum

```bash
# name指定包  state指定状态
ansible ho -m yum -a 'name=httpd state=latest' 安装
ansible ho -m yum -a 'name=httpd state=absent' 删除
```

### Service
```bash
# 关闭服务  name指定服务名称  state指定状态
ansible ho -m service -a 'name=httpd state=stopped'
ansible ho -m service -a 'name=httpd state=started'
ansible ho -m service -a'name=httpd state=reloaded'
ansible ho -m service -a'name=httpd state=restarted'
```

### User
```bash
ansible ho -m user -a 'name=user comment="test user" uid=2048 home=/app/user group=root'
ansible ho -m user -a 'name=sysuser system=yes home=/app/syseser1'
ansible ho -m user -a 'name=user state=absent remove=yes' 删除用户以及家目录等数据
```

### setup
获取ansible信息，ansible执行完成后,会将结果接到ansible_facts 这个变量当中去，而setup可以输出这个变量
```bash
➜  /tmp ansible -i hosts all -m setup
[WARNING]: Unable to parse the plugin filter file /etc/ansible/plugin_filters.yml as module_blacklist is not a list. Skipping.

10.0.28.58 | SUCCESS => {
    "ansible_facts": {
        "ansible_all_ipv4_addresses": [
            "10.0.28.58"
        ],
        "ansible_all_ipv6_addresses": [
            "fe80::b116:4b55:85a6:c563"
        ],
        "ansible_apparmor": {
            "status": "disabled"
        },
        "ansible_architecture": "x86_64",
        "ansible_bios_date": "05/14/2015",
        "ansible_bios_version": "0504",
        "ansible_cmdline": {
            "BOOT_IMAGE": "/vmlinuz-3.10.0-1062.12.1.el7.x86_64",
            "LANG": "zh_CN.UTF-8",
            "crashkernel": "auto",
            "quiet": true,
            "rd.lvm.lv": "centos/swap",
            "rhgb": true,
            "ro": true,
            "root": "/dev/mapper/centos-root"
        },
```
setup模块返回的是ansible中的一些信息，包括修改后更换的结果，使用filter可以来过滤出我们需要的信息
```bash
➜  /tmp ansible all -m setup -a 'filter=ansible_hostname'

10.0.28.58 | SUCCESS => {
    "ansible_facts": {
        "ansible_hostname": "node"
    },
    "changed": false
}
```
并且支持通配符匹配
比如我们要过滤出所有包含hostname的字段
```bash
ansible all -m setup -a 'filter=*address*'
10.0.28.58 | SUCCESS => {
    "ansible_facts": {
        "ansible_all_ipv4_addresses": [
            "10.0.28.58"
        ],
        "ansible_all_ipv6_addresses": [
            "fe80::b116:4b55:85a6:c563"
        ]
    },
    "changed": false
}
```

# 其他

- 模块
https://www.cnblogs.com/f-ck-need-u/p/7550603.html
https://docs.ansible.com/ansible/2.6/modules/list_of_all_modules.html

- ansible模块开发
https://www.jianshu.com/p/f72b79b0d3f9  