---
title: ansible-playbook
categories:
  - ansible
tags:
  - ansible
abbrlink: 2ced8538
date: 2020-03-11 10:45:53
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [ansible-playbook](#ansible-playbook)
  - [命令使用](#命令使用)
    - [ansible-playbook 的文件加密](#ansible-playbook-的文件加密)
    - [ansible-playbook 交互式命令](#ansible-playbook-交互式命令)
  - [核心组件](#核心组件)
    - [比较](#比较)
    - [例子1](#例子1)
    - [例子2](#例子2)
    - [例子3](#例子3)
    - [例子4 开启一个httpd服务](#例子4-开启一个httpd服务)
    - [例子5 ansible-playbook使用变量](#例子5-ansible-playbook使用变量)
  - [ansible-playbook中的项目分层](#ansible-playbook中的项目分层)
  - [ansible-playbook配置文件动态加载 template](#ansible-playbook配置文件动态加载-template)
  - [template 使用循环](#template-使用循环)
  - [ansible-playbook with_items 循环](#ansible-playbook-with_items-循环)
  - [ansible-playbook 使用role角色](#ansible-playbook-使用role角色)
    - [项目结构](#项目结构)
  - [报错总结](#报错总结)
    - [远端机器上默认的python环境问题](#远端机器上默认的python环境问题)
  - [ansible-playbook中的几种状态](#ansible-playbook中的几种状态)

<!-- /code_chunk_output -->
<!-- more -->

# ansible-playbook
![2020-03-12-10-37-56](http://noback.upyun.com/2020-03-12-10-37-56.png)
ansible-playbook 文件需要以yaml的形式存在
```bash
name: tom
age: 21
gender: male
spourse:
    name: lily
    gender: female
children:
    - name: susan
      age: 2　
      gender: feamle
    - name: sunny
      age: 10
      gender: male
```

<font color='red'>写一个可以运行的ansible-playbook的实例</font>
```yaml
vi /tmp/xx.yaml
# hosts 表示运行的host组  remote_user表示运行的身份
# tasks 表示运行的任务，可以有多个tasks  name 表示这个任务的名字
# command 表示运行的模块  
--- 
- hosts: nameservers 
  remote_user: root

  tasks:
    - name: hello
    - command: hostname
```
运行
```bash
ansible-playbook xx.yaml
```


## 命令使用
```bash
ansible-playbook [options] playbook.yml [playbook2 ...]
```


### ansible-playbook 的文件加密
ansible-playbook 支持对yaml文件进行加入
```bash
➜  /tmp ansible-vault encrypt xx.yaml

New Vault password:
Confirm New Vault password:
Encryption successful
➜  /tmp cat xx.yaml
$ANSIBLE_VAULT;1.1;AES256
30633938633633636639626166383730623730323365623631643063336634363737636461616466
3761393163336232323735643331636262373136323862360a643335313537356334363431356635
66313364323434396566396232363664633861613139646138303530353665626561316136333766
3932626465366236320a346532636663323236616231356136663330623365333465336537383336
64313533633132316230623038343839326232333736383230353535303739346466633730323538
30636136303236623961643461363331383039336432346436303030373238333332663035343938
31373939343965643934643135373336323666363130613635666261633165313137616331313837
32663739663732373561626465613965346537653033333739623263323135383037633631343430
3835
```
加密后的文件无法运行
```bash
➜  /tmp ansible-playbook xx.yaml
ERROR! Attempting to decrypt but no vault secrets found
```
对加密后的文件进行解密
```bash
➜  /tmp ansible-playbook xx.yaml

ERROR! Attempting to decrypt but no vault secrets found
➜  /tmp ansible-vault decrypt  xx.yaml

Vault password:
Decryption successful
➜  /tmp
➜  /tmp cat xx.yaml
- hosts: 10.0.28.58
  remote_user: root

  tasks:
    - name: hello
      command: hostname
```
在保持加密的情况下，查看加密后文件或者修改加密的文件(需要输入密码)
```bash
ansible-vault view xx.yaml # 查看
ansible-vault editor xx.yaml # 编辑
ansible-vault rekey xx.yaml # 修改密码
ansible-vault create xx2.yaml # 创建一个新的yaml的同时，添加密码
```

### ansible-playbook 交互式命令
```bash
# 使用ansible-console可以进入交互式命令
```

## 核心组件
- Hosts 执行的远程主机列表
- Tasks 任务集
- Varniables 内置变量或自定义变量在playbook中调用
- Templates 模板,可替换模板文件中的变量并实现一些简单逻辑的文件
- Handlers 和 notity 结合使用,由特定条件触发的操作，满足条件方才执行,否则不执行
- roles 角色
- tags 标签  指定某条任务执行,用于选择运行playbook中的部分代码。ansible具有幂等性,因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间

一个组件一个组件的来介绍


### 比较
adhoc 和 playbook 对比
```bash
# adhoc 改变主机名字
ansible ho -m hostname -a 'name=xxx'
# playboot 修改主机名字
---
- host: ho
  remote_user: root
  
  tasks:
  - name: hello
    hostname: name=node
```
多条adhoc 和playbook对比
```bash
# adhoc 
ansible ho -m file -a 'name=/data/newfile state=touch'  # 创建文件
ansible ho -m user -a 'name=test2 system=yes shell=/sbin/nologin' # 创建用户
ansible ho -m yum -a 'name=httpd' # 安装httpd
ansible ho -m copy -a 'src=/var/www/html/index.html dest=/var/www/html' # 复制文件
ansible ho -m service -a 'name=httpd state=started enabled=yes' # 启动服务


# playbook
- hosts: ho
  remote_user: root
  
  tasks:
  - name: create file
    file: name=/data/newfile state=touch
  - name: create user
    file: name=test2 system=yes shell=/sbin/nologin
  - name: install httpd
    yum: name=httpd
  - name: copy file
    copy: src=/var/www/html/index.html dest=/var/www/html
  - name: start service
    service: name=httpd state=started enabled=yes
```

shell脚本与playbook对比
```bash
# shell脚本

#!/bin/bash
# 安装Apache
yum install --quiet -y httpd
# 复制配置文件
cp /tmp/httpd.conf /etc/httpd/conf/httpd.conf
cp /tmp/vhosts.conf /etc/httpd/conf.d/
# 启动Apache 并设置开机启动
systemctl start httpd.service
chkconfig httpd on

# playbook
---
- host: all
  tasks:
   - name: "安装Apache"
     yum: name=httpd
   - name: "复制配置文件"
     copy: src=/tmp/httpd.conf dest=/etc/httpd/conf/
   - name: "复制文件"
     copy: src=/tmp/vhosts.conf dest=/etc/httpd/conf.d/
   - name: "启动Apache,并设置开机启动"
     service: name=httpd state=started enabled=yes
```

### 例子1
```yaml
vim /root/first.yml

- hosts: all
  remote_user: root
  vars: httpd_port=80
  
  tasks:
  - name: install httpd
    yum: name=httpd state=present
  - name: install php
    yum: name=php state=present
  - name: start httpd
    service: name=httpd state=started enabled=true
```
hosts 定义单个主机或组，
- vars定义变量
变量的命名形式: 字母数字下划线组成，只能以字母开头
  - facts 内置变量
  由远程主机发回的主机属性信息，这些信息被保存在ansible变量当中
  例如：ansible 192.168.238.170 -m setup 来获取远程主机上的属性信息，这些属性信息保存在facts中
  -  传递方式 ： 通过命令行的方式传递变量
  例如: ansible-playbook -i lists deploy.yml -e 'node=BBC-JL-CGQ role=marco' -t config
  这里面传递了 node=BBC-JL-CGQ role=marco的命令。
  <font color='red'>如果剧本中已有此处定义的变量则会被覆盖</font>
  - 通过role传递
  - 通过inventroy传递
  [nameserver]
  192.168.0.1 var=haha
  - 组变量
  [nameserver:vars]
  foo=bar
- remote_user定义执行命令的远程用户，
- tasks定义执行哪些命令，
  - 在tasks中调用变量的是{{ variables }}
  - when 用来做条件判断
- handlers定义调用哪些处理器

### 例子2
```yaml
vim /root/second.yml

- hosts: web1
  remote_user: root
  vars:
    username: bob
    password: 123
    
  tasks:
  - name: add user
    user: name={{ username }} state=present
    when: ansible_os_family == "Debian"
  - name: set password
    shell: echo {{ password }} |passwd --stdin {{ username }}
  - name: install httpd php
    yum: name={{ item }} state=present
    with_items:
      - httpd
      - php
  - name: add two users
    user: name={{ item }} state=present groups={{ item.groups }}
    with_items:
    - { name: 'user1', groups: 'group1'}
    - { name: 'user2', groups: 'group2'}
    
```
with_items 是tasks中的内置变量
name 是每一个task任务都必须要有的名字

### 例子3
```yaml
vim /root/third.yml

- hosts: web1
  remote_user: root
  vars: 
    httpd_port=80
  
  tasks:
  - name: install httpd
    yum: name=httpd state=present
  - name: install php
    yum: name=php state=present
  - name: copy config file
    copy: src=/root/httpd.conf dest=/etc/httpd/conf/httpd.conf
    notify: restart httpd
  - name: start httpd
    service: name=httpd state=started enabled=true
    
  handlers:
  - name: restart httpd
    service: name=httpd state=restarted

```
copy是将src即本地的文件拷贝到 dest远端的机器上面是
handlers是句柄的意思，可以定义一些常用的流程，比如重启服务
notify用来调用句柄的 ，比如上面调用了handlers 来重启服务

### 例子4 开启一个httpd服务
```bash
vi /etc/xx.yaml


 ---
  - hosts: nameserver
    remote_user: root

    tasks:
      - name: hello·
        command: hostname
      - name: install httpd package
        yum: name=httpd·
        tags: installhttpd
      - name: stop service
        service: name=httpd state=stopped enabled=yes
        tags: stophttp
      - name: start service
        service: name=httpd state=started enabled=yes
        tags: rehttpd
      

# 直接运行ansible-playbook
ansible-playbook xx.yaml
# 指定标签运行,运行stophttpd 关闭httpd服务
ansible-playbook xx.yaml -t stophttp
# 关闭再执行
ansible-playbook xx.yaml -t stophttp,rehttpd
```

### 例子5 ansible-playbook使用变量
```yaml
# vi /tmp/xx.yaml
  ---
  - hosts: nameserver
    remote_user: root

    tasks:
      - name: install  package
        yum: name={{ package }}·
        tags: installpackage

# ansible-playbook  xx.yaml -e 'package=httpd'
```
使用双花括号来获取包名变量
使用-e 来输入变量

<font color='red'>-e可以达到外部传入变量的效果，vars可以达到内部定义变量的效果</font>

```yaml
# vi /tmp/xx.yaml

  ---
  - hosts: nameserver
    remote_user: root
    vars:
      - package: httpd
    tasks:
      - name: install  package
        yum: name={{ package }}·
        tags: installpackage

# ansible-playbook xx.yaml
```

## ansible-playbook中的项目分层
通常在小的ansible项目中，因为tasks任务少，或者是单线流程，我们通常把ansible-playbook写在一个文件里面，同样的，他所使用的vars也少，完全可以写在一个yaml文件中，但是一旦项目多起来了，vars之间过多，写在yaml中不够详细，变量名重复等等，我们完全可以建立一个文件，在Yaml中读取
```bash
vi /tmp/vars.yml
  app1: httpd
  app2: mysql


vi xx.yml
  ---
  - hosts: nameserver
    remote_user: root
    vars_files:
      ¦- vars.yml
    tasks:
      - name: install  package
        yum: name={{ app1 }}·
        tags: installpackage
      - name: install  package
        yum: name={{ app2 }}·
        tags: installpackage

# ansible-playbook xx.yml
```

## ansible-playbook配置文件动态加载 template
假定我们现在有21台服务器，其中1台是我们的主控机，即通过ansible发送ngxin配置文件到其他20台服务器上，
主控机中的nginx配置文件中 映射的端口是80端口，且CPU是根据主机的CPU来自定义生成nginx服务的，但是在其他的20台服务器中，其中5台我们需要映射的是85端口，其中5台是90端口，其中5台式CPU*2的数量 另外5台是CPU2+端口100，对于这些机器，我们不可能每次修改的时候都去重新更改一遍nginx中的内容，如果我们这样做，我们可以使用copy模块去执行ansible 但是如果要满足动态的效果，我们就要制作一个template模版

<font color='red'>注意nginx软件是在epel镜像上下载的</font>


另外templates文件支持Jinja2模版
```bash
# 在/etc/ansible下面创建templates文件
mkdir -p /etc/ansible/templates
# 复制本机的nginx.conf到/templates下面
cp /etc/nginx/nginx.conf /etc/ansible/templates/nginx.conf.j2
# 修改监听端口
vi /etc/ansible/templates/nginx.conf 
listen 22; => listen {{ port }}
# 编写xx.yml vi /tmp/xx.yml
  ---
  - name: get_nginx_conf
    hosts: nameserver
    remote_user: root
    vars:
      - port: 81
    tasks:
      - name: install nginx
        yum: name=nginx
      - name: copy nginx conf
        template: src=/etc/ansible/templates/nginx.conf.j2 dest=/etc/nginx/nginx.conf
        notify: restart httpd
      - name: start nginx service
        service: name=nginx state=started enabled=yes

    handlers:
    - name: restart httpd
      service: name=httpd state=restarted
```
于是当我们想要对前面2个5组服务器修改端口时候，只需要修改端口就行了
或者直接在命令行中覆盖修改
```bash
ansible-playbook xx.yml -e 'port=81'
```
或者在其他文件中定义

<font color='red'>根据CPU数量动态加载nginx</font>

```bash
# 查看cpu数量
➜  /tmp ansible all -m setup -a "filter=*cpu*"
10.0.28.58 | SUCCESS => {
    "ansible_facts": {
        "ansible_processor_vcpus": 2
    },
    "changed": false
}

# 根据CPU数量动态加载
vi /etc/ansible/template/nginx.conf.j2

worker_processes  {{ ansible_processor_vcpus**2 }};

# 启动
ansible-playbook  xx.yml

# 查看nginx启动数量
[root@node yum.repos.d]# ps -aux | grep nginx
root     29916  0.0  0.0  56820  1188 ?        Ss   17:16   0:00 nginx: master process /usr/sbin/nginx
nginx    29917  0.0  0.0  57288  2012 ?        S    17:16   0:00 nginx: worker process
nginx    29918  0.0  0.0  57288  2012 ?        S    17:16   0:00 nginx: worker process
nginx    29919  0.0  0.0  57288  2012 ?        S    17:16   0:00 nginx: worker process
nginx    29920  0.0  0.0  57288  2012 ?        S    17:16   0:00 nginx: worker process
root     29960  0.0  0.0 112712   964 pts/2    S+   17:17   0:00 grep --color=auto nginx
```

## template 使用循环
语法使用jinja2语法
```yaml
vi /tmp/xx.yaml


    - name: get_nginx_conf
    ¦ hosts: nameserver
    ¦ remote_user: root
    ¦ vars:
    ¦ ¦ ports:
    ¦ ¦ ¦ - 62
    ¦ ¦ ¦ - 99·
    ¦ ¦ ¦ - 1010

    ¦ tasks:
    ¦ ¦ - name: create data files
    ¦ ¦ ¦ file: name=/data state=directory
    ¦ ¦ - name: create files
    ¦ ¦ ¦ template: src=/etc/ansible/templates/template.conf.j2 dest=/data/test.conf
```

```bash
vi /etc/ansible/template.conf.j2

  {% for port in ports %}
  ▏ {% if port == 62 %}
  ▏ ▏ ▏ server {
  ▏ ▏ ▏ ▏ ▏ ssh_port = 67
  ▏ ▏ ▏ }
  ▏ {% else %}
  ▏ server {
  ▏ ▏ ssh_port =  {{port}}
  ▏ }
  ▏ {%endif%}
  {% endfor %}
```

输出结果
```bash
➜  /tmp ansible all -m shell -a "cat /data/test.conf"

10.0.28.58 | CHANGED | rc=0 >>
                        server {
                sh_port = 62
        }
                        server {
                ssh_port =  99
        }
                        server {
                ssh_port =  1010
        }
```

## ansible-playbook with_items 循环
如果我们要创建多个文件，频繁的使用
```bash
file: name=/tmp/xxx 
file: name=/tmp/yyy
file: name=/tmp/qqq 
```
这样的做法是不合理的，最好的做法是使用循环
```yml
file: name=/tmp/{{ item }}
with_items:
 - file1
 - file2
 - file3


  ---
  - name: get_nginx_conf
    hosts: nameserver
    remote_user: root
  ··
    tasks:
      - name: create files
        file: name={{ item }} state=touch
        with_items:
          - file1
          - file2
          - file3
      - name: install packages
        yum: name={{ item }}
        with_items:
          - nginx
          - sl
          - hping3
```
<font color='red'>字典循环</font>

```yml
file: name=/tmp/{{ item }}
with_items:
 - file1
 - file2
 - file3

  ---
  - name: get_nginx_conf
    hosts: nameserver
    remote_user: root

    tasks:
      - name: create files
        file: name=/{{ item.dest }}/{{ item.name }} state=directory
        with_items:
          - {dest: '/tmp/',name: 'xxx'}
          - {dest: '/etc/',name: 'yyy'}
          - {dest: '/hzj/',name: 'test'}
          - {dest: '/qqq/',name: 'xxx'}
```

## ansible-playbook 使用role角色
role角色的存在主要是层次性 结构化的组织playbook,roles根据层次型结构自动装在变量文件 tasks handlers等等
比如我们可以将nginx mysql 这些服务模块分成一类一类的模块(我们称之为角色),使用主控文件夹yaml来控制我们使用哪些角色

```bash
# 创建roles文件夹
cd /etc/ansible
mkdir roles

# 创建角色文件夹，角色文件夹中需要存在tasks handlers等任务文件夹
mkdir -p ./roles/{nginx,uwsgi,mysql}/{tasks,templates,vars,files} #递归创建目录结构的命令

# 查看目录结构
➜  ansible tree ./roles
./roles
├── mysql
│   ├── files
│   ├── tasks
│   ├── templates
│   └── vars
├── nginx
│   ├── files
│   ├── tasks
│   ├── templates
│   └── vars
└── uwsgi
    ├── files
    ├── tasks
    ├── templates
    └── vars
```
另外我们还需要一个主控yaml文件来控制roles,该yaml文件与roles文件夹同级
```yml

```

### 项目结构
![2020-03-12-22-15-08](http://noback.upyun.com/2020-03-12-22-15-08.png)


roles下面的子文件夹
![2020-03-12-22-16-45](http://noback.upyun.com/2020-03-12-22-16-45.png)

## 报错总结

### 远端机器上默认的python环境问题
报错内容
```bash
fatal: [10.0.28.58]: FAILED! => {"changed": false, "msg": "The Python 2 bindings for rpm are needed for this module. If you r
equire Python 3 support use the `dnf` Ansible module instead.. The Python 2 yum module is needed for this module. If you requ
ire Python 3 support use the `dnf` Ansible module instead."}
```
远端机器上默认的python环境为python3，但是ansible支持的是python2
这里要规定一下python的环境
```bash
vi /etc/ansible/hosts

[nameserver]
10.0.28.58 ansible_python_interpreter=/usr/bin/python2.7
```



## ansible-playbook中的几种状态
```bash
# state
state=stopped
state=started
state=reloaded
state=restarted
```