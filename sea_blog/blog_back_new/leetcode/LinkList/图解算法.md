---
title: 图解算法
categories:
  - leetcode
tags:
  - leetcode
abbrlink: 90ec9eea
date: 2019-12-29 13:07:36
---


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [图解算法](#图解算法)
  - [二分查找](#二分查找)
    - [例子1](#例子1)
    - [练习](#练习)

<!-- /code_chunk_output -->

<!--more -->

# 图解算法

这个博文可能跟图解算法的内容讲的不一样，一般都是看了书之后换一种自己认为更加形象的比喻去理解内容，如果想要看图解算法的可以去购买或者查找一些PDF的书籍，笔记对于算法和数据结构并不像语言那样，对于版本的更迭有一定程度的影响。另外，算法图解这本书中的实例都是依靠Python编写的。

## 二分查找
其实二分法在我们生活中已经出现过了很多次，比如玩一个猜价格游戏，规定价格在500-1000之内，如果我们一个一个的去猜，则需要猜1000-500-2次，但是使用二分法猜测价格时，即每次对半猜测价格，那么每次都可以减去一半的错误价格，就像一张白纸对半折一样，最后的区域则会越来越小。而使用的次数则是log2n步。
同样的例子也存在于字典中，查字典的手法同样也可以使用二分法。

**概念:最多需要猜测的次数与列表长度相同，这被称为线性时间**

### 例子1
创建一个函数，接受一个有序数组和一个元素，如果指定的元素出现在数组中，则返回其位置
```bash
def filter_number(list,keywords):
    for i in range(len(list)):
        if list[i] == keywords:
            print(i)
if __name__ == "__main__":
    list = [1,2,4,5,343,67,86,656]    
    keywords = 343
    filter_number(list,keywords)
```
如上所示是普通的遍历方法，遍历5次后得到343这个参数。但如果匹配的数字是656，则需要匹配7次，如果数组的长度是1000,匹配的结果是最后一个，则需要匹配1000次，这样就增加了负担
```bash
# 二分查找匹配
def filter_number(list,keywords):
    first = 0
    end = len(list) - 1
	
    while first <= end:
        mid = int((first+end) / 2)
        guess = list[mid]
        if guess == keywords:
            return mid
        elif guess < keywords:
            first = mid + 1
        elif guess > keywords:
            end = mid - 1
    return None 

if __name__ == "__main__":
    list = [1,2,4,5,6,8,9,10,11]    
    keywords = 8
    index = filter_number(list,keywords)
    print(index)
```
如上则完成了需求,**但是二分查找存在一个问题，则是如果列表不是按照顺序排列的，那么二分法就存在的意义就不大了，因为当你使用二分法得到中间值时，你只能判断中间值与题目给出的元素之间大小，而中间值的附近元素，并不是依次递增或是递减的**

### 练习
假设有一个包含128个名字的有序列表，你要使用二分查找在其中查找一个名字，请 问最多需要几步才能找到
2的7次等于128  所以是7次
上面列表的长度翻倍后，最多需要几步？
8次

