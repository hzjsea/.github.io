---
title: 链表
categories:
  - leetcode
tags:
  - leetcode
  - 链表
abbrlink: 2362a8ea
date: 2020-07-19 12:29:27
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [链表实现](#链表实现)
  - [线性表的实现](#线性表的实现)
  - [链表](#链表)
    - [单节点](#单节点)
    - [头指针与头结点以及尾节点](#头指针与头结点以及尾节点)
    - [单链表的增删改查 C 语言实现](#单链表的增删改查-c-语言实现)
    - [单链表增删改查 python 语言实现](#单链表增删改查-python-语言实现)
    - [单链表增删改查 rust 语言实现](#单链表增删改查-rust-语言实现)
    - [双链表 C 语言实现](#双链表-c-语言实现)
    - [双链表 py 语言实现](#双链表-py-语言实现)
    - [双链表 rust 语言实现](#双链表-rust-语言实现)

<!-- /code_chunk_output -->

<!-- more -->

# 链表实现

链表算是最基本的数据结构了吧
链表的诞生主要是因为顺序表在插入和删除的时候会比较慢，因为每次改动，都会动 n 个元素。而链表在插入或者删除的时候，最多要动前后两个元素

## 线性表的实现

顺序表和链表都统称为线性表，但是他们在结构上以及存储原理上是有很多不同的

顺序表存储: 顺序表存储是将数据元素放到一块连续的内存存储空间,因此顺序表在一开始就要规定好存储空间的大小，存储的效率高，速度快，但是不可以动态的增加长度

- 优点: 存取速度高效，通过下标来直接存储
- 缺点: 1.插入和删除比较慢，2.不可以增长长度 # 比如：插入或者删除一个元素时，整个表需要遍历移动元素来重新排一次顺序

链表的存储: 链表的存储是在程序运行过程动态分配空间的，只要存储器中海油空间，就不会发生存储溢出的问题

- 优点: 插入和删除速度快，只需要改变元素的指针就行了
- 缺点: 查找速度慢，因为查找的时候，需要遍历链表，知道查找到元素

因此频繁的插入和删除可以选择链表，而频繁的查找可以选择顺序表

## 链表

数组是一种顺序表。
链表相对于数组来说，要复杂的多，首先，链表不需要连续的内存空间，它是由一组零散的内存块透过指针连接而成，所以，每一个块中必须包含当前节点内容以及后继指针。最常见的链表类型有单链表、双链表以及循环链表。
下面就来介绍一下链表的内容，分别分为三种链表

- 单链表
- 双链表
- 循环链表

### 单节点

在链表中，我们以单个节点来表示单个元素，每个节点中包含了两个内容，一个是`data`另外一个是`next` next 是当前节点的后驱，指向下一个节点

```bash
->[node1 | data | next] -> [node2 | data | next] -> null
```

### 头指针与头结点以及尾节点

在链表中，位于链表头部的节点我们叫做`头结点`，当链表为空的时候，头结点的下一跳为空
在链表中，位于链表尾部的结点我们叫做`尾节点`, 尾节点在单链表中，下一跳始终指向空
为了方便操作，很多人会在头节点前再加一个前驱，也就是头指针，头指针可以看做一个节点，他可以含有 data(但是为了方便区分，尽量不要给他赋值) 头指针始终指向头结点。摧毁链表的条件就是头指针所指向的头结点不存在 也就是`(*head)->next == NULL`

```bash
[firstnode | data | next] -> [node1 | data |next] -> null
[node1 | data | next] -> [tailnode | data |next] -> null
[ head | data=None | next ] -> [firstnode | data | next] -> null
```

![2020-07-19-19-04-27](http://noback.upyun.com/2020-07-19-19-04-27.png)

### 单链表的增删改查 C 语言实现

![2020-07-19-19-35-27](http://noback.upyun.com/2020-07-19-19-35-27.png)

```c
//2020-07-11 16:22:18
#include <stdio.h>
#include <stdlib.h>

// 单链表无头指针
// 链表中，节点与节点之间都是使用节点的地址来进行连接的

// 节点模板   [data,next] -> [data,next] ->null
struct Node
{
    int data;
    struct Node *next;
};

// 使用typedef 定义别名

typedef struct Node node;         // 普通节点
typedef struct Node *nodeAddress; // 返回一个节点地址
typedef struct nodeAddress *head; // 返回一个头指针的地址 也就是 **head

// 节点创建
// 传入一个头指针， 头指针指向头结点，头指针可以没有任何值
int createNode(nodeAddress *head)
{
    // 创建一个节点，返回节点的地址
    nodeAddress newnode;
    // 给节点分配内存地址,并且进行变量的强制转换
    newnode = (nodeAddress)malloc(sizeof(struct Node));
    // 给节点分配内容
    newnode->data = 1;
    newnode->next = NULL;
    return 0;
}

// 初始化节点 [data=null,next] -> [data=0;next] -> null
// 创建一个节点， 设置变量
// 头指针->头结点->null
// 返回头指针地址
// 有个问题 看到请回答 返回的到底是头结点的地址还是头指针的地址
int InitList(nodeAddress *head, int val)
{
    nodeAddress newnode;
    newnode = (nodeAddress)malloc(sizeof(struct Node));
    newnode->data = val;
    newnode->next = NULL;
    // 这里传入的只是一个节点的地址  **head 才表示头指针
    (*head)->next = newnode;
    return 0;
}

// 接下来是增删改查

// 插入节点
// 传入一个初始化后的链表的头指针地址
// 从后插入一个值
nodeAddress InsertListTail(nodeAddress head, int val)
{
    // 创建一个游标  确定位置
    nodeAddress current = head;
    nodeAddress newnode;
    newnode = (nodeAddress)malloc(sizeof(struct Node));
    newnode->data = val;
    newnode->next = NULL;

    // 确定尾结点的位置
    while (current->next != NULL)
    {
        current = current->next;
    }
    current->next = newnode;

    return head; // 返回头结点
}

// 从尾部删除节点
// 获得倒数第二个节点
// 将倒数第一个节点指向NULL
// 为了防止内存溢出，还要释放掉分配的内存
nodeAddress DeleteListTail(nodeAddress head)
{
    nodeAddress current = head;
    while (current->next->next != NULL)
    {
        current = current->next;
    }
    current->next = NULL;
    free(current->next);
    return head;
}

// 从尾部修改节点
nodeAddress UpdateListTail(nodeAddress head, int val)
{
    nodeAddress current = head;
    while (current->next != NULL)
    {
        current = current->next;
    }
    current->data = val;
    return head;
}

// 查看最后一个节点的值
void LookListTail(nodeAddress head)
{
    nodeAddress current = head;
    while (current->next != NULL)
    {
        current = current->next;
    }
    printf("%d", current->data);
}

// 从头部插入节点 用有指针来操作
// 插入头指针
// 创建节点
// 新头结点指向老的头结点
// 头指针指向新头结点

int InsertListHead(nodeAddress *head, int val)
{
    nodeAddress newnode = (nodeAddress)malloc(sizeof(struct Node)); // 创建新的节点
    newnode->data = val;
    newnode->next = NULL;

    nodeAddress first = (*head)->next;

    newnode->next = first;
    (*head)->next = newnode;
    return 0;
}

// 从头部删除节点
// 找到头结点(node1)的下一个节点为node2
// 头指针指向noint
// node1 指向null 并且释放掉内存
// 疑问 需要指向null嘛 可不可以直接释放内存

int DeleteListHead(nodeAddress *head)
{
    // 判断是否为空链表
    if ((*head)->next == NULL)
    {
        return 0;
    }

    // 否则
    nodeAddress current = (*head)->next;
    (*head)->next = current->next;
    current->next = NULL;
    free(current);

    return 1;
}

// 修改头部结点
int UpdateListHead(nodeAddress *head, int val)
{
    nodeAddress first = (*head)->next;
    first->data = val;
    return 1;
}

// 查找头结点
int LookListHead(nodeAddress *head, int val)
{
    nodeAddress first = (*head)->next;
    printf("%d", first->data);
    return 0;
}

//  接下来是全局

// 计算链表的长度
// 返回int长度
int ListLength(nodeAddress head, int val)
{
    nodeAddress current = head;
    int count = 0;
    while (current->next != NULL)
    {
        current = current->next;
        count++;
    }
    return count;
}

// 遍历所有的结点
void TraverseList(nodeAddress *head)
{
    // 判断链表是否为空
    if ((*head)->next == NULL)
    {
        printf("NULL");
    }
    nodeAddress current = (*head)->next;
    while (current != NULL)
    {
        printf("%d\n", current->data);
        current = current->next;
    }
}

// 判断是否为空链表，即 头指针的下一跳为空 [data=null,next] -> null
int isEmpty(nodeAddress *head)
{
    if ((*head)->next != NULL)
    {
        return 1; // 不为空
    }
    else
    {
        return 0; // 为空
    }
}

// 在指定index下添加节点
int InsertListIndex(nodeAddress head, int index, int val)
{
    int current_id = 1;
    nodeAddress current = head;
    for (current_id = 1; current_id < index; current_id++)
    {
        current = current->next;
    }
    nodeAddress newnode = (nodeAddress)malloc(sizeof(struct Node));
    newnode->next = current->next;
    newnode->data = val;
    current->next = newnode;
    return 1;
}

// 在指定index下删除节点
int DeleteListIndex(nodeAddress head, int index)
{
    int current_id = 1;
    nodeAddress current = head;
    for (current_id = 1; current_id < index; current_id++)
    {
        current = current->next;
    }
    current->next = current->next->next;
    nodeAddress deleteNode = current->next;
    deleteNode = NULL;
    free(deleteNode);
    return 1;
}

// 在指定index下查找值
int LookLinkListIndex(nodeAddress head, int index)
{
    int current_id = 1;
    nodeAddress current = head;
    for (current_id = 1; current_id < index; current_id++)
    {
        current = current->next;
    }
    printf("%d", current->data);
    return 1;
}

// 修改指定index下的值
int UpdateLinkListIndex(nodeAddress head, int index, int val)
{
    int current_id = 1;
    nodeAddress current = head;
    for (current_id = 1; current_id < index; current_id++)
    {
        current = current->next;
    }
    current->data = val;
    return 1;
}

// 清空链表
// 保留头部
int ClearLinkList(nodeAddress head)
{
    nodeAddress current = head;
    // 双指针
    nodeAddress current_backup = head;
    while (current->next != NULL)
    {
        current_backup = current->next->next;

        free(current->next);
        current->next = current_backup;
    }
    head->next = NULL;
    return 1;
}

// 摧毁链表
// 先销毁了链表的头，然后接着一个一个的把后面的销毁了，这样这个链表就不能再使用了，即把包括头的所有节点全部释放。
int DestoryLinkList(nodeAddress *head)
{
    nodeAddress first = (*head)->next;
    nodeAddress current = first;
    while (first)
    {
        (*head)->next = current->next;
        free(current);
    }
    return 0;
}
int main()
{
    // 创建一个节点
    nodeAddress head;
    InitList(&head, 20);
    head = InsertListTail(head, 30);
    InsertListHead(&head, 200);

    InsertListIndex(head, 2, 3);
    TraverseList(&head);
    DeleteListIndex(head, 2);
    // TraverseList(&head);
    ClearLinkList(head);
    TraverseList(&head);
    DestoryLinkList(&head);
    TraverseList(&head);
    return 0;
}
```

### 单链表增删改查 python 语言实现

![2020-07-19-19-35-27](http://noback.upyun.com/2020-07-19-19-35-27.png)

```py
#!/hzj/myenv python3
# -*- encoding: utf-8 -*-
'''
@File    :   singlist.py
@Time    :   2020/07/19 10:00:37
@Author  :   hzjsea@
@Version :   1.0
@Contact :   hzjsea@gmail.com
@gayhub  :   hzjsea@github.com
@License :   (C)Copyright 2017-2018, Liugroup-NLPR-CASIA
@Desc    :   no tower gods, only  climb towers
'''

# Desc:===================
# Code:==================


# 定义一个节点

class Node:
    def __init__(self, val=None, next=None):
        self.data = val
        self.next = next

    def __str__(self):
        return str(self.data)


# 链表关系
# node1->node2->node3


# 创建一个链表
class LinkList(object):
    def __init__(self, head=Node(0, None)):
        self.head = head  # 头结点

    def __len__(self):
        # 功能：输入头节点，返回链表长度
        curr = self.head
        counter = 0
        while curr is not None:
            counter += 1
            curr = curr.next
        return counter

    def IsEmpty(self):
        if self.head is None:
            return None
        else:
            return self.head.data

    def InsertListTail(self, data):
        # 尾插法
        if data is None:
            return None
        curr = self.head
        while curr is not None:
            curr = curr.next
        newnode = Node(data, None)
        curr.next = newnode

    def InsertListHead(self, data):
        # 头插法
        if data is None:
            return None
        node = Node(data, self.head)
        self.head = node
        return node

    def LookList(self, data):
        if data is None:
            return None
        curr = self.head
        while curr is None:
            if curr.val == data:
                return curr
            curr = curr.next
        return None

    def DeleteList(self, data):
        if data is None:
            return None
        if self.head is None:
            return None
        if self.head.data == data:
            self.head = self.head.next
            return
        prev_node = self.head
        curr_node = self.head.next
        while curr_node is not None:
            if curr_node.data == data:
                prev_node.next = curr_node.next
            else:
                prev_node = curr_node
                curr_node = curr_node.next

    def DeleteList2(self):
        if self.head is None:
            return

        curr = self.head
        while curr.next is not None:
            curr.next = curr.next.next
            return
            curr = curr.next

```

### 单链表增删改查 rust 语言实现

pass


### 双链表 C 语言实现

双链表相对于单链表来说 多了一个前驱元素指向上一个节点,并且尾节点指向头结点

```c
#include <stdio.h>
#include <stdlib.h>

// 双链循环链表

// 节点
struct Node
{
    int val;
    struct Node *prior; // 指向上一个节点的地址
    struct Node *next;  // 指向下一个节点的地址
};

// 返回一个节点
typedef struct Node newnode;
// 返回一个节点的地址
typedef struct Node *nodeAddress;

// 空链表
nodeAddress InitList(int val, nodeAddress *head)
{
    // 创建一个新的节点
    nodeAddress newnode = (nodeAddress)malloc(sizeof(struct Node));
    (*head)->next = newnode;
    newnode->next = newnode;
    newnode->val = val;
    // newnode -> next = NULL;
    newnode->prior = newnode;
    return newnode;
}

// 从指定位置处插入节点
int InsertListBylocation(int val, nodeAddress head, int index)
{
    // 新增节点
    nodeAddress newnode = (nodeAddress)malloc(sizeof(struct Node));
    newnode->val = val;
    newnode->next = NULL;
    newnode->prior = NULL;

    // 判断终止条件
    if (head == NULL || index < 0)
    {
        return 0;
    }

    // 插入表头
    if (index == 1)
    {
       
        newnode->next = head;
        head->prior = newnode;
    }
    // 创建游标
    nodeAddress current = head;
    for (int i = 0; i < index - 1; i++)
    {
        current = current->next;
    }
    // 判断节点位置
    if (current->next == NULL)
    {
        // 说明是尾节点
        current->next = newnode;
        newnode->prior = current;
    }
    else
    {
        // 说明是中间节点
        newnode->prior = current;
        newnode->next = current->next;
        current->next->prior = newnode;
        current->next = newnode;
    }

    return 1;
}

// 遍历输出
int TraverseList(nodeAddress head)
{
    if (head == NULL)
    {
        return 0;
    }
    nodeAddress current = head;
    while (current)
    {
        printf("%d\n", current->val);
        current = current->next;
    }
    return 0;
}


int main()
{
    struct Node *L;
    L = InitList(2, &L);
    // AddListTaril(3,L);
    InsertListBylocation(3, L, 1);
    InsertListBylocation(3, L, 2);
    TraverseList(L);
    return 0;
}

```


### 双链表 py 语言实现
```py

# 创建节点


class Node(object):
    def __init__(self,data=None,next=None):
        self.data = data
        self.next = None
        self.pre = None
    
    def __repr__(self):
        return str(self.data)

# 创建链表
class DoubleList():
    def __init__(self):
        self.head = None
    # 判断是否为空
    def isEmpty(self):
        return self.head is None
    # 初始化双链表
    def InitList(self,value:int):
        self.head = Node(value)
        self.head.next = self.head
        self.head.pre = self.head

    
    # 追加节点 尾插法
    def AddList(self,value:int):
        # 创建节点
        newnode = Node(value)
        # 关联节点
        current = self.head
        # 由于双向链表的特殊性，尾插法的尾节点=self.head.pre
        while current.next != self.head:
            current = current.next
        current.next = newnode
        newnode.pre = current
        newnode.next = self.head
        self.head.pre = newnode

    # 获取链表长度
    def __len__(self):
        count = 1
        current = self.head
        while current.next != self.head:
            count +=1
            current = current.next
        print(count)
    # 循环输出节点
    def ConsoleElement(self):
        current = self.head
        while current.next != self.head:
            print(current.data)
            current = current.next
        print(current.data)


    # 删除节点
    def DelList(self,index:int):
        current = self.head
        if index < 0 or self.head == None:
            return 0
        while index:
            current = current.next
            index -=1
        
        tmpnode = current.next

        current.next = current.next.next
        current.next.pre = current
        tmpnode.next = None
        tmpnode.pre = None

    # 修改节点
    def getIndexList(self,index:int,value:int):
        current = self.head
        if index < 0 or self.head ==None:
            return 0
        while index :
            current = current.next
            index -=1
        current.data =  value

if __name__ == '__main__':
    dl = DoubleList()
    dl.InitList(20)
    dl.AddList(30)
    dl.AddList(30)
    dl.__len__()
    dl.DelList(1)
    dl.__len__()
    dl.ConsoleElement()
    dl.getIndexList(1,20)
    dl.ConsoleElement()

    
```
### 双链表 rust 语言实现
pass