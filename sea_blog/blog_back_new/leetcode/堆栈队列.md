---
title: 堆栈队列
categories:
  - leetcode
tags:
  - leetcode
abbrlink: ee1b1b67
date: 2020-09-23 12:02:40
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- more -->


# 堆栈队列

## 堆栈
口语中的堆栈有两种，一种是数据结构中的堆栈，另一种是计算机组成中的堆栈。

## 堆
堆(heap)也被称为`优先队列`，队列中允许的操作是`先进先出(FIFO)` `first in first out`，在队尾插入元素，在队头取出元素。而堆也是一样，在堆底插入元素，在堆顶取出元素,二叉树的衍生，有最小堆最大堆的两个概念，将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。 

队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。
- 进行插入操作的端称为队尾，
- 进行删除操作的端称为队头。
队列中没有元素时，称为空队列
队列采用 先进先出 FIFO(first in first out)，新元素（等待进入队列的元素）总是被插入到链表的尾部，而读取的时候总是从链表的头部开始读取。每次读取一个元素，释放一个元素。所谓的动态创建，动态释放。因而也不存在溢出等问题。由于链表由结构体间接而成，遍历也方便

![2020-09-23-14-11-24](http://noback.upyun.com/2020-09-23-14-11-24.png)

## 栈
栈(stack)又名`堆栈`，作为一个 先进后出 的数据结构。（注意：这里的堆栈本身就是栈，只是换了个抽象的名字
它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

![2020-09-23-14-11-16](http://noback.upyun.com/2020-09-23-14-11-16.png)




## 队列
队列，队列有三种形式
- 先进先出队列，也叫做FIFO队列，任务按照添加的顺序取出，就是上面说的堆
- 后进先出队列，也叫做LIFO队列，类似堆栈，后添加的任务先取出
- 优先级队列，队列里面的任务按照优先级排序，优先级高的先被取出来


### Python队列实现与使用
::: tip 
单线程队列实现，无阻塞 
:::

```py
#!/usr/bin/env python3
# encoding: utf-8
'''
@author: hzj
@file: queueTest2.py
@time: 2020/9/25 3:31 下午
'''

class Queue(object):
    def __str__(self):
        return str(self.queue)

    def __init__(self,size):
        self.size = size
        self.queue = []

    # 获取队列的当前长度
    def getSize(self) -> int:
        return len(self.queue)

    # 入队
    def enqueue(self,item) -> int:
        if self.isfull():
            return -1
        self.queue.append(item)

    # 判断队列是否已满
    def isfull(self) -> bool:
        if self.size == self.getSize():
            return True
        return False

    # 判断队列是否为空
    def isEmpty(self) -> bool:
        if len(self.queue) == 0:
            return True
        return False

    # 出队
    def dequeue(self) -> int:
        if self.isEmpty():
            return -1
        element = self.queue[0]
        self.queue.remove(element)
        return element


if __name__ == '__main__':

    # 创建队列
    queueTestxx = Queue(20)

    # 批量入队
    for i in range(1,20):
        queueTestxx.enqueue(i)

    # 批量出队
    for i in range(1,20):
        print(queueTestxx.dequeue())

    # 判断是否为空
    print(queueTestxx.isEmpty())

    # 判断是否满了
    print(queueTestxx.isfull())

    # 单线程队列，并不能起到阻塞的作用

```


::: tip 
使用自带的queue库实现 
:::
```py
"""
python队列实现
"""

import queue

# 创建队列，如果不设置长度，默认为无限长
q = queue.Queue()

# 返回队列中当前的元素
print(q.maxsize)

# 入队
for i in range(1,10):
    q.put(i)

# 出队
for i in range(1,10):
    q.get()

# 当队列中只有4个元素的时候，如果出队去了5个数字，则这个时候队列会产生阻塞，只有当下一个第五个元素进入的是否才会输出
for i in range(1,5):
    q.put(i)

for i in range(1,6):
    q.get()
```




### Python中的队列
```py
class queue.Queue(maxsize=0)
class queue.LifoQueue(maxsize=0)
class queue.PriorityQueue(maxsize=0)
```
当没有设置maxsize的时候，队列长度为无限大,如果设置了，则表示设置可以放入当前队列中的任务数的上线

- 添加任务
```py
>>> import queue
>>> q = queue.Queue(maxsize=1)
>>> q.put(100)
```
函数方法如下`Queue.put(item, block=True, timeout=None)`
```py
import queue

# 创建队列，如果不设置长度，默认为无限长
q = queue.Queue(maxsize=1)
q.put(2)
q.put(1,True,2) # 报错 queue.FULL
```
默认情况下，在队列满时，该函数会一直阻塞，直到队列中有空余的位置可以添加任务为止。如果 timeout 是正数，则最多阻塞 timeout 秒，如果这段时间内还没有空余的位置出来，则会引发 Full 异常

block 是非阻塞模式，也就是当`block=false`的时候，timeout失效。
```py
>>> import queue
>>> q = queue.Queue(maxsize=1)
>>> q.put(100)
>>> q.put(100,False,2)  # 不需要等待2s  直接报错
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "E:\Python37-32\lib\queue.py", line 136, in put
    raise Full
queue.Full
```

`Queue.put_nowait(item)` 相当于 `Queue.put(item,False)`

- 获取任务
`get()` 函数也有两个可选参数，完整签名如下 `Queue.get(block=True, timeout=None)`
默认情况下，当队列空时调用该函数会一直阻塞，直到队列中有任务可获取为止。如果 timeout 是正数，则最多阻塞 timeout 秒，如果这段时间内还没有任务可获取，则会引发 Empty 异常
```py
>>> import queue
>>> q = queue.Queue()
>>> q.put(100)
>>> q.get()
100
>>> q.get(True,2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "E:\Python37-32\lib\queue.py", line 178, in get
    raise Empty
_queue.Empty # 2 秒钟内没有任务可获取则引发 Empty 异常
>>> q.get() # 该方法会一直阻塞
```
当 block 为 false 时，timeout 参数将失效。同时如果队列中没有任务可获取则会立刻引发 Empty 异常，否则会直接获取一个任务并返回，不会阻塞。
```py
>>> import queue
>>> q = queue.Queue()
>>> q.put(100)
>>> q.get() 
100
>>> q.get(False,2)  # 直接报错
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "E:\Python37-32\lib\queue.py", line 167, in get
    raise Empty
_queue.Empty 
# 指定为非阻塞模式，队列为空则立即引发 Empty 异常
```

`Queue.get_nowait()` 来获取任务，相当于 `Queue.get(False)`


- 获取队列大小
```py
import queue
q = queue.Queue()
q.put(100)
print(q.qsize())
```

- 判断队列是否满或者是否空
```py
import queue

# 创建队列，如果不设置长度，默认为无限长
q = queue.Queue(maxsize=1)

# 判断队列是否为空
flag = q.empty()
print(flag)

# 判断队列是否满
full_flag = q.full()
print(full_flag)

```

- FIFO队列
```py
import queue

# FIFO队列 先进先出
q = queue.Queue(maxsize=20)
for index in range(1,11):
    q.put(index)

while not q.empty():
    print(q.get())
# res
# 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 
```

- LIFO队列
```py
import queue
q = queue.LifoQueue() # 创建一个 LIFO 队列
for index in range(10):
    q.put(index)
while not q.empty():
    print(q.get(), end=", ")

# res
# 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 
```

- 优先级队列
优先级队列中的任务顺序跟放入时的顺序是无关的，而是按照任务的大小来排序，最小值先被取出。那任务比较大小的规则是怎么样的呢.
    - 如果是内置类型，比如数值或者字符串，则按照自然顺序来比较排序。
    - 如果是列表或者元祖，则先比较第一个元素，然后比较第二个，以此类推，直到比较出结果
```py
import queue
q = queue.PriorityQueue()
for index in range(10,0,-1):
    q.put(index)
while not q.empty():
    print(q.get(), end=", ")
## 输出结果如下
# 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 
```

```py
import queue
q = queue.PriorityQueue()
q.put(["d","b"])
q.put(["c","b"])
while not q.empty():
    print(q.get(), end=", ")
## 输出结果如下
# ['c', 'b'], ['d', 'b'], 
```

优先级队列里面的内容数据类型不能相同

- 优先级队列 自定义类型
```py
import queue
q = queue.PriorityQueue()

class Animal:
    def __init__(self, age, name):
        self.age = age
        self.name = name
    def __lt__(self, other): 
        return self.age < other.age # 同类进行比较的时候，会比较age

q.put(Animal(3,"cat"))
q.put(Animal(2,"dog"))

while not q.empty():
    animal = q.get()
    print(animal.name, animal.age, end=", ")
## 输出结果如下
dog 2, cat 3, 
```

### Golang中的队列实现
Golang里面，队列主要由切片来实现
```go
package main

import "fmt"

// 实现FIFO队列
// 创建类

type Element interface {}

// 创建队列实现
type FIFOQueue interface {
	push(e Element) // 添加元素
	pop() Element // 删除元素
	clear() bool // 清空元素
	Size() int // 返回队列内元素数量
	IsEmpty() bool // 判断队列是否为空
}

type sliceEntry struct {
	slice []Element
}


// 创建队列
func NewQueue() *sliceEntry{
	return &sliceEntry{}
}

// 添加元素
func (this *sliceEntry) push(e Element) {
	this.slice = append(this.slice,e)
}

// 删除元素
func(this *sliceEntry) pop() Element{
	if this.IsEmpty(){
		fmt.Println("这是一个空队列")
		return nil
	}
	firstElement := this.slice[0]
	this.slice = this.slice[1:]
	return firstElement
}

// 判断队列是否为空
func (this *sliceEntry) IsEmpty() bool {
	if len(this.slice)==0{
		return true
	}
	return false
}

// 清除队列
func (this *sliceEntry) Clear() bool{
	if this.IsEmpty(){
		fmt.Println("queue is empty")
		return false
	}
	for i:=0;i<this.Size();i++{
		this.slice[i] = nil
	}
	this.slice = nil
	return true
}

// 输出队列大小
func (this *sliceEntry) Size() int  {
	return len(this.slice)
}

```


golang FILO队列实现
```go
package main

import "fmt"

// 实现FILO队列

// 创建队列中的数据类型
type element interface {}

// 创建队列实现
type FILOqueue interface {
	push (e element) // 添加元素
	pop ()  element // 删除元素
	clear() // 清除元素
	Size()  int // 计算队列中元素的数量
	IsEmpty() bool //是否为空
}

// 队列实现
type FILqueue struct {
	slice []element
}

func NewQueue2() *FILqueue{
	return &FILqueue{}
}

func (this *FILqueue) push(e element) {
	this.slice = append(this.slice,e)
}


func (this *FILqueue) pop() element{
	if this.IsEmpty(){
		return nil
	}
	// 因为这个是先进后出， 所以pop删除的应该是数组中的最后一位
	lastindex := this.slice[len(this.slice)-1:]
	this.slice = this.slice[:len(this.slice)-1]
	return lastindex
}

func (this *FILqueue) IsEmpty() bool{
	if len(this.slice) == 0{
		return true
	}
	return false
}

func (this *FILqueue) Size() int {
	return len(this.slice)
}

func (this *FILqueue) clear()	{
	this.slice = nil
}

func main() {
	filqueue := NewQueue2()
	for i :=0 ;i<20;i++{
		filqueue.push(i)
	}
	fmt.Println(filqueue)
	fmt.Println(filqueue.Size())
	fmt.Println(filqueue.pop())
	fmt.Println(filqueue.pop())
}
```
## 有关于队列堆栈的算法

### 有效的括号
https://leetcode-cn.com/problems/valid-parentheses/solution/

