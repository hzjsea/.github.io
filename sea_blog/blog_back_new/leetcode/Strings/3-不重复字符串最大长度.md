---
title: 不重复字符串最大长度
categories:
  - leetcode
tags:
  - leetcode
abbrlink: d4558412
date: 2020-10-20 17:39:51
---

![2020-10-20-17-40-26](http://noback.upyun.com/2020-10-20-17-40-26.png)
<!-- more -->
# 不重复字符串最大长度

## 解决方法

子字符串的方法通常是使用滑动窗口来解决的，通过滑动窗口来规划一个区域用于匹配。

1. 创建一个map 作为窗口，分别记录值内容和下标
2. 声明最大长度为max 以及左下标left，右下标为right
3. 右下标不断递增，直到等于s的长度
4. 递增过程中，往窗口中记录值圈住的值内容和下标， 以及计算max内容 max内容为上一个max和当前max max的计算方法为 右下标-左下标+1
5. 递增过程中，如果匹配到当前的值内容出现在窗口中，则移动left1位

## java代码
```java
    // 不重复字符串最大长度
    // https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-jie-suan-fa-3-wu-zhong-fu-zi-fu-de-zui-chang-z/
    public int lengthOfLongestSubstring(String s) {
        if (s.length() == 0) return 0;
        // 窗口
        HashMap<Character,Integer> map = new HashMap<>();
        // 最长子串长度
        int max = 0;
        // 滑动窗口做左下标,i作为右下标
        int left = 0;
        for (int i =0;i<s.length();i++){
            // 如果map中包含了重复的值 ，则left进1位
            if (map.containsKey(s.charAt(i))){
                left = Math.max(left,map.get(s.charAt(i))+1);
            }
            // 每次移动就
            map.put(s.charAt(i),i);
            // 维护一个最大长度
            max = Math.max(max,i-left+1);
        }
        return max;

    }

    // 不重复字符串最大长度
    public int lengthOfLongestSubstring2(String s){
        if  (s.length() == 0) return 0;
        // 窗口
        Map<Character,Integer> windows = new HashMap<>();
        int max = 0;
        int left = 0;
        for (int right=0;right<s.length();right++){
            if (windows.containsKey(s.charAt(right))){
                // 如果发现有相同的内容，直接推进到当前
                left = Math.max(left,windows.get(s.charAt(right))+1);
            }
            // 否则就正常添加
            windows.put(s.charAt(right),right);
            max = Math.max(max,right-left+1);
        }
        return max;
    }
```
