---
title: go_多进制
date: 2021-05-17 16:08:54
categories:  [golang]
tags: [golang]
---


<!--more-->


# 多进制


二进制是硬件底层实现的基础，可以了解一下二进制，但是一般也不会使用到。编译的程序也是以二进制存储的。
十六进制是方便查看的，本质上还是将二进制的数据以十六进制显示出来。为什么不使用二进制来显示，因为二进制显示出来很不方便查看。
常见的进制还有八进制与十进制，打开计算器切换到程序员模式，可以看到，3个二进制位最多能表示0-7共8个数，4个二进制位能表示0-15共16个数，
电路中只能进行二进制逻辑运算，所以二进制是基础中的基础。之所以使用16进制，我认为是因为现在的通常情况下每8bit为一个字节，而16进制里一位数正好能表示一个字节，虽说本质上还是二进制代码，但16进制表示的话也更便于查看和修改。
就拿最简单的RGB颜色来说，调成黑色或者白色的话16进制直接用#000或者#FFF就能表示，改用二进制还得打24个0或者24个1，看上去就复杂不少还容易出错


## 八进制

二进制是机器能够识别的最直接语言，但是二进制位数太多，不方便记录，所以一般把二进制转化为八进制或十六进制。为什么不直接把二进制转化为十进制呢？因为二进制转化为十进制较麻烦，不够直观，而二进制转化为八进制或十六进制十分方便，3位二进制可转化为1位八进制，4位二进制可转化为1位十六进制，比如二进制111转化为八进制7，二进制1111转化为十六进制F。只有3位或4位二进制转化为十进制还是比较容易，但是如果多位二进制呢？就很麻烦了，比如二进制1111111111111111转化为十进制，很难秒算出来，需要借助计算器，但是转化为十六进制就不一样了，四位四位二进制合并为一位十六进制就可以了，即二进制（1111111111111111）=十六进制（FFFF），一目了然很方便，只要记住下图16个二进制转化为十六进制的数字即可。
总结：十进制主要运用于日常生活当中，而二进制、八进制、十六进制主要运用于电子技术行业，二进制是数字电路、处理器等最直接的语言，八进制、十六进制由于有着方便转化记录的意义而使用，如今更多的是十六进制进行存储记忆，八进制较少使用，比如处理器里的寄存器、存储器的地址、数据都是使用十六进行进行表示。
八进制有 0~7 共8个数字，基数为8，加法运算时逢八进一，减法运算时借一当八。例如，数字 0、1、5、7、14、733、67001、25430 都是有效的八进制

## 十六进制

除了二进制和八进制，十六进制也经常使用，甚至比八进制还要频繁。
十六进制中，用A来表示10，B表示11，C表示12，D表示13，E表示14，F表示15，因此有  0~F 共16个数字，基数为16，加法运算时逢16进1，减法运算时借1当16。例如，数字  0、1、6、9、A、D、F、419、EA32、80A3、BC00 都是有效的十六进制。
就是为了简洁。例如一个16位的二进制数1010010111001011，无论写起来还是读起来，很费事儿，还容易出错，写成十六进制数A5CD，就方便多了，也不容易出错


## ascii表
在计算机中，所有的数据在存储和运算时都要使用二进制数表示（因为计算机用高电平和低电平分别表示1和0），例如，像a、b、c、d这样的52个字母（包括大写）以及0、1等数字还有一些常用的符号（例如*、#、@等）在计算机中存储时也要使用二进制数来表示，而具体用哪些二进制数字表示哪个符号，当然每个人都可以约定自己的一套（这就叫编码），而大家如果要想互相通信而不造成混乱，那么大家就必须使用相同的编码规则，于是美国有关的标准化组织就出台了ASCII编码，统一规定了上述常用符号用哪些二进制数来表示

ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。 2的8次方式256个


- 0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等；通信专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等；ASCII值为8、9、10 和13 分别转换为退格、制表、换行和回车字符。它们并没有特定的图形显示，但会依不同的应用程序，而对文本显示有不同的影响。
- 32～126(共95个)是字符(32是空格），其中48～57为0到9十个阿拉伯数字。
- 65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。

这样加起来一共是127位 因此只需要7位2进制就能表示了，多出一位用来做扩展ASCII码的确定位 扩展ASCII 码允许将每个字符的第8 位用于确定附加的128 个特殊符号字符、外来语字母和图形符号

<div style='font-size:20px;color:red'>因此基本ascii码表中，第一位都是0 而扩展的ASCII表中，第一位是1</div> 


但是这个只适用于美国的， 对于其他的国家来说，每个国家都有不同的字符，如果使用ascii来表示的话， 就不够用了，于是后面有了 <div style='font-size:20px;color:red'>unicode</div>

## unicode

- Unicode 是字符集
- utf 是一种编码规则
- utf-8 是其中一个特殊的编码规则


字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point） 即 key-value
编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程 

统一码，也叫万国码、单一码（Unicode）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。

### utf-8
说到unicode 就要提一句utf-8

unicode本身就是一个字符集，可以确定在一个巨大的数据库当中，unicode对应的是key,而字符则对应的是value，他们总是以键值对的形式存在，key-value，
比如 知乎日报，转换成unicode就是这样，左边的是对应字符，右边对应的是16进制
```bash
I 0049  
t 0074
' 0027
s 0073
  0020
知 77e5
乎 4e4e
日 65e5
报 62a5
```
这时候我们来看下ascii表，其实对于前面的部分，是和基本的ascii是对应上的. 但是对于扩展的ascii表中的内容，则对应不上
![](https://noback.upyun.com/2021-05-18-14-02-36.png!)

接下来我们把16进制转换成二进制再来看看
```bash
I 00000000 01001001
t 00000000 01110100
' 00000000 00100111
s 00000000 01110011
  00000000 00100000
知 01110111 11100101
乎 01001110 01001110
日 01100101 11100101
报 01100010 10100101
```

如上，对于基本的ascii码来说，前面的9位都是0 ，这就造成了硬盘上的浪费

于是后面就出现了utf， utf(unicode transformation)是一种编码规则，utf-8是一种规范的常用的并且被大部分人认可的编码规则，他定义了如下的规则

1. 对于单字节的字符，字节的第一位设为0，因此前面所列出来内容中，I原本是 `00000000 01001001` 现在就可以简写为 `01001001`
2. 对于n个字节的字符,比如说中文字符，第一个字节的前n位设置为1，第n+1位设置为0 后面的每个字节前两位都设置为10 这样做只是为了打标记，并且用0来作为隔离，其余部分用unicode码。 你可以发现一个规则，他们都是2的倍数，也就是说对于多个字节的字符，首先第一个字节去掉4位标记 第二个字节去掉2位做标记，第三个字节去掉2位做标记  比如上面的知，原本是 `01110111 11100101`现在可以拆分为`[4]0111 [2]011111 [2]100101`，再补上标记位，就是`11100111 10011111 10100101`

最后根据16进制的返回，也出现了utf-8的模板
```bash
U+ 0000 ~ U+  007F: 0XXXXXXX # 单字节 对应基本的ascii表
U+ 0080 ~ U+  07FF: 110XXXXX 10XXXXXX
U+ 0800 ~ U+  FFFF: 1110XXXX 10XXXXXX 10XXXXXX
U+10000 ~ U+10FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX
```
转换过程
```bash
根据上表中的编码规则，之前的「知」字的码位 U+77E5 属于第三行的范围：

       7    7    E    5    
    0111 0111 1110 0101    二进制的 77E5
--------------------------
    0111   011111   100101 二进制的 77E5
1110XXXX 10XXXXXX 10XXXXXX 模版（上表第三行）
11100111 10011111 10100101 代入模版
   E   7    9   F    A   5
```

Unicode的实现方式不同于编码方式。一个字符的Unicode编码确定。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF