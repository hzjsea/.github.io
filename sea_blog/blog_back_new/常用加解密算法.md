---
title: 常用的加解密算法
date: 2021-07-01 19:02:49
categories:  [RSA,MD5,Base64]
tags: [RSA,MD5,Base64]
---


<!--more-->


# 常用的加解密算法
常用的对称加密算法：DES、AES、3DES、RC2、RC4
常用的非对称加密算法：RSA、DSA、ECC
单向散列函数的加密算法：MD5、SHA

## RSA 公秘钥加解密
openssl会产生一对公私秘钥，他们作用是对传输数据进行加解密，两者相反。
- 公钥加密，私钥解密
- 私钥加密，公钥解密  (这个也能做，但是我看网上这么做的人并不多，但实际需求中有碰到过)

两个秘钥是相对的，两者本身并没有规定哪一个必须是公钥或私钥

第一种形式用的比较多, 比如ssh, ssh 采用的是公钥加密，私钥解密的方式
1. 远程主机(ssh server) 收到用户(client) 的登录请求之后，会把自己的公钥发给用户
2. 用户使用这个公钥，将登录密码加密后，发送回来
3. 远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录

![](https://noback.upyun.com/2021-07-04-15-31-51.png!)



### 中间人攻击
因为client加密所使用的公钥是server自身的，中间人攻击主要发生在这一阶段，如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。

因此假设伪造公钥给到了client，client加密后发送到了伪造公钥的server ,server 在用对应的私钥去解密出登录密码，在用登录密码伪造身份去登录主机，么SSH的安全机制就荡然无存了。这种风险就是著名的“中间人攻击”（Man-in-the-middle attack）
![](https://noback.upyun.com/2021-07-04-15-35-52.png!)


### 对称算法与非对称算法
如果使用对称加密算法，`加解密使用同一个密钥`，除了自己保存外，对方也要知道这个密钥，才能对数据进行解密。如果你把密钥也一起传过去，就存在密码泄漏的可能。所以我们使用非对称算法，过程如下:

- 首先 接收方 生成一对密钥，即私钥和公钥；
- 然后，接收方 将公钥发送给 发送方；
- 发送方用收到的公钥对数据加密，再发送给接收方；
- 接收方收到数据后，使用自己的私钥解密

### 公钥指纹
首次登录主机的时候，会有一段话，如下
```bash
$ ssh username@host
The authenticity of host 'host (12.18.429.21)' can't be established.
RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.
Are you sure you want to continue connecting (yes/no)?
```

这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。

### 公钥登录

所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。

### 签名
私钥签名，公钥验签

除了保证数据的安全传输之外，公钥体系的另一个用途就是对数据进行签名，通常“数字签名”是用来验证发送方的身份并帮助保护数据的完整性。

一个发送者 A 想要传些资料给大家，用自己的私钥对资料加密，即签名。这样一来，所有收到资料的人都可以用发送者的公钥进行验证，便可确认资料是由 A 发出来的了。（因为只有Ａ使用私钥签名得到的信息，才能用这个公钥来解） 采用数字签名，可以确认两点：

- 保证信息是由签名者自己签名发送的，签名者不能否认或难以否认。
- 保证信息自签发后收到为止未曾做过任何的修改

### 公钥算法的缺点
公钥机制也有它的缺点，那就是效率非常低，比常用的私钥算法（如 DES 和 AES）慢上一两个数量级都有可能。所以它不适合为大量的原始信息进行加密。为了同时兼顾安全和效率，我们通常结合使用公钥算法和私钥算法

- 首先，发送方使用`对称算法`对原始信息进行加密。
- 接收方通过公钥机制生成一对密钥，一个公钥，一个私钥。
- 接收方 将公钥发送给 发送方。
- 发送方用公钥对对称算法的密钥进行加密，并发送给接收方。
- 接收方用私钥进行解密得到对称算法的密钥。

- 发送方再把已加密的原始信息发送给接收方。
- 接收方使用对称算法的密钥进行解密。


### go中 rsa加解密算法展示
```go
package main

import (
    "log"
    "errors"
    "github.com/wenzhenxi/gorsa"
)

var Pubkey = `-----BEGIN 公钥-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAk+89V7vpOj1rG6bTAKYM
56qmFLwNCBVDJ3MltVVtxVUUByqc5b6u909MmmrLBqS//PWC6zc3wZzU1+ayh8xb
UAEZuA3EjlPHIaFIVIz04RaW10+1xnby/RQE23tDqsv9a2jv/axjE/27b62nzvCW
eItu1kNQ3MGdcuqKjke+LKhQ7nWPRCOd/ffVqSuRvG0YfUEkOz/6UpsPr6vrI331
hWRB4DlYy8qFUmDsyvvExe4NjZWblXCqkEXRRAhi2SQRCl3teGuIHtDUxCskRIDi
aMD+Qt2Yp+Vvbz6hUiqIWSIH1BoHJer/JOq2/O6X3cmuppU4AdVNgy8Bq236iXvr
MQIDAQAB
-----END 公钥-----
`

var Pirvatekey = `-----BEGIN 私钥-----
MIIEpAIBAAKCAQEAk+89V7vpOj1rG6bTAKYM56qmFLwNCBVDJ3MltVVtxVUUByqc
5b6u909MmmrLBqS//PWC6zc3wZzU1+ayh8xbUAEZuA3EjlPHIaFIVIz04RaW10+1
xnby/RQE23tDqsv9a2jv/axjE/27b62nzvCWeItu1kNQ3MGdcuqKjke+LKhQ7nWP
RCOd/ffVqSuRvG0YfUEkOz/6UpsPr6vrI331hWRB4DlYy8qFUmDsyvvExe4NjZWb
lXCqkEXRRAhi2SQRCl3teGuIHtDUxCskRIDiaMD+Qt2Yp+Vvbz6hUiqIWSIH1BoH
Jer/JOq2/O6X3cmuppU4AdVNgy8Bq236iXvrMQIDAQABAoIBAQCCbxZvHMfvCeg+
YUD5+W63dMcq0QPMdLLZPbWpxMEclH8sMm5UQ2SRueGY5UBNg0WkC/R64BzRIS6p
jkcrZQu95rp+heUgeM3C4SmdIwtmyzwEa8uiSY7Fhbkiq/Rly6aN5eB0kmJpZfa1
6S9kTszdTFNVp9TMUAo7IIE6IheT1x0WcX7aOWVqp9MDXBHV5T0Tvt8vFrPTldFg
IuK45t3tr83tDcx53uC8cL5Ui8leWQjPh4BgdhJ3/MGTDWg+LW2vlAb4x+aLcDJM
CH6Rcb1b8hs9iLTDkdVw9KirYQH5mbACXZyDEaqj1I2KamJIU2qDuTnKxNoc96HY
2XMuSndhAoGBAMPwJuPuZqioJfNyS99x++ZTcVVwGRAbEvTvh6jPSGA0k3cYKgWR
NnssMkHBzZa0p3/NmSwWc7LiL8whEFUDAp2ntvfPVJ19Xvm71gNUyCQ/hojqIAXy
tsNT1gBUTCMtFZmAkUsjqdM/hUnJMM9zH+w4lt5QM2y/YkCThoI65BVbAoGBAMFI
GsIbnJDNhVap7HfWcYmGOlWgEEEchG6Uq6Lbai9T8c7xMSFc6DQiNMmQUAlgDaMV
b6izPK4KGQaXMFt5h7hekZgkbxCKBd9xsLM72bWhM/nd/HkZdHQqrNAPFhY6/S8C
IjRnRfdhsjBIA8K73yiUCsQlHAauGfPzdHET8ktjAoGAQdxeZi1DapuirhMUN9Zr
kr8nkE1uz0AafiRpmC+cp2Hk05pWvapTAtIXTo0jWu38g3QLcYtWdqGa6WWPxNOP
NIkkcmXJjmqO2yjtRg9gevazdSAlhXpRPpTWkSPEt+o2oXNa40PomK54UhYDhyeu
akuXQsD4mCw4jXZJN0suUZMCgYAgzpBcKjulCH19fFI69RdIdJQqPIUFyEViT7Hi
bsPTTLham+3u78oqLzQukmRDcx5ddCIDzIicMfKVf8whertivAqSfHytnf/pMW8A
vUPy5G3iF5/nHj76CNRUbHsfQtv+wqnzoyPpHZgVQeQBhcoXJSm+qV3cdGjLU6OM
HgqeaQKBgQCnmL5SX7GSAeB0rSNugPp2GezAQj0H4OCc8kNrHK8RUvXIU9B2zKA2
z/QUKFb1gIGcKxYr+LqQ25/+TGvINjuf6P3fVkHL0U8jOG0IqpPJXO3Vl9B8ewWL
cFQVB/nQfmaMa4ChK0QEUe+Mqi++MwgYbRHx1lIOXEfUJO+PXrMekw==
-----END 私钥-----
`


func main() {
    // 公钥加密私钥解密
    if err := applyPubEPriD(); err != nil {
        log.Println(err)
    }
    // 公钥解密私钥加密
    if err := applyPriEPubD(); err != nil {
        log.Println(err)
    }
}

// 公钥加密私钥解密
func applyPubEPriD() error {
    pubenctypt, err := gorsa.PublicEncrypt(`hello world`,Pubkey)
    if err != nil {
        return err
    }

    pridecrypt, err := gorsa.PriKeyDecrypt(pubenctypt,Pirvatekey)
    if err != nil {
        return err
    }
    if string(pridecrypt) != `hello world` {
        return errors.New(`解密失败`)
    }
    return nil
}

// 公钥解密私钥加密
func applyPriEPubD() error {
    prienctypt, err := gorsa.PriKeyEncrypt(`hello world`,Pirvatekey)
    if err != nil {
        return err
    }

    pubdecrypt, err := gorsa.PublicDecrypt(prienctypt,Pubkey)
    if err != nil {
        return err
    }
    if string(pubdecrypt) != `hello world` {
        return errors.New(`解密失败`)
    }
    return nil
}
```

### python中 rsa加解密算法展示
目前看来 python大部分的库都只支持公钥加密，私钥解密的形式

```python
#!/usr/bin/env python3
# encoding: utf-8

"""
@author: hzjsea
@file: ciq.py.py
@time: 2021/7/1 8:29 下午
"""

import base64
import rsa
from loguru import logger

class CryptoSign():
    """
    公钥加密，私钥解密
    用私钥签名认证，再用公钥验证签名
    """

    def __init__(self,fpath_ri='./pri.pem',fpath_ub='./pub.pem'):
        # self.gen_rsakey()
        # 私钥
        with open(fpath_ri,'r+') as f:
            prikeydata = f.read()
            f.close()
        self.privatekey = rsa.PrivateKey.load_pkcs1(prikeydata)

        # 公钥
        with open(fpath_ub, 'r+') as f:
            pubkeydata = f.read()
        self.publickey = rsa.PublicKey.load_pkcs1(pubkeydata)


    def gen_rsakey(self):
        (pubkey,privkey) = rsa.newkeys(1024) # 数字
        with open("./pri.pem",'wb') as f:
            pri = privkey.save_pkcs1()
            f.write(pri)
            f.close()
        with open("./pub.pem","wb") as f:
            pub = pubkey.save_pkcs1()
            f.write(pub)
            f.close()

    # 公钥对数据加密
    def pub_encrypt(self,data):
        if isinstance(data,str):
            data = data.encode('utf-8')
        enc = rsa.encrypt(data,self.publickey)
        ret = base64.b64encode(enc).decode(encoding='utf-8')
        print(ret)
        return ret

    # 私钥对数据解密
    def pri_decrypt(self,data):
        try:
            data = base64.b64decode(data)
            return rsa.decrypt(data, self.privatekey).decode('utf-8')
        except Exception as e:
            msg = "error decrypt ---> {}".format(e)
            logger.debug(msg)
            return msg


if __name__ == '__main__':
    cs = CryptoSign()
    ret = cs.pub_encrypt("09Cw1pH3pt9YYEHIlYVSv6JEhpNDui7l") # 用公钥加密
    # print(cs.pri_decrypt(ret)) # 私钥解密

```

```python
from Crypto import Random
from Crypto.Cipher import PKCS1_v1_5 as PKCS1_cipher
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA
from Crypto.Signature import PKCS1_v1_5 as PKCS1_signature

import base64



random_generator = Random.new().read
rsa = RSA.generate(1024, random_generator)

# 私钥
private_key = rsa.exportKey()
with open("private_a.rsa", 'wb') as f:
    f.write(private_key)

# 公钥
public_key = rsa.publickey().exportKey()
with open("public_a.rsa", 'wb') as f:
    f.write(public_key)



# 使用公钥对内容进行rsa加密
message = "09Cw1pH3pt9YYEHIlYVSv6JEhpNDui7l"
# with open('public_a.rsa') as f:
#     key = f.read()
#     pub_key = RSA.importKey(str(key))
#     cipher = PKCS1_cipher.new(pub_key)
#     rsa_text = base64.b64encode(cipher.encrypt(bytes(message.encode("utf8"))))
#     print(rsa_text.decode('utf-8'))
#
# # 使用私钥对内容进行rsa解密
# with open('private_a.rsa') as f:
#     key = f.read()
#     pri_key = RSA.importKey(key)
#     cipher = PKCS1_cipher.new(pri_key)
#     back_text = cipher.decrypt(base64.b64decode(rsa_text), 0)
#     print(back_text.decode('utf-8'))


with open('private_a.rsa') as f:
    key = f.read()
    pri_key = RSA.importKey(str(key))
    cipher = PKCS1_cipher.new(pri_key)
    rsa_text = base64.b64encode(cipher.encrypt(bytes(message.encode("utf8"))))
    print(rsa_text.decode('utf-8'))

with open('public_a.rsa') as f:
    key = f.read()
    pub_key = RSA.importKey(key)
    cipher = PKCS1_cipher.new(pub_key)
    back_text = cipher.decrypt(base64.b64decode(rsa_text), 0)
    print(back_text.decode('utf-8'))

# message = "需要加密的信息"
# # 使用私钥生成签名
# with open('private_a.rsa') as f:
#     key = f.read()
#     pri_key = RSA.importKey(key)
#     signer = PKCS1_signature.new(pri_key)
#     digest = SHA.new()
#     digest.update(message.encode("utf8"))
#     sign = signer.sign(digest)
#     signature = base64.b64encode(sign)
#     print(signature.decode('utf-8'))
#
# # 使用公钥验证签名
# with open('public_a.rsa') as f:
#     key = f.read()
#     pub_key = RSA.importKey(key)
#     verifier = PKCS1_signature.new(pub_key)
#     digest = SHA.new()
#     digest.update(message.encode("utf8"))
#     print(verifier.verify(digest, base64.b64decode(signature)))


```

## MD5加密算法

MD5是哈希算法的一种，可以将任意数据产生出一个128位（16字节）的散列值，用于确保信息传输完整一致。

<div style='font-size:20px;color:red'>md5是一种信息摘要算法，它是不可逆的，不可以解密，就是一种单向的加密算法</div>

我们常在注册登录模块使用MD5，用户密码经过MD5加密后存入数据库。
这样用户在登录的时候，密码经过MD5加密后再与数据库中存储的数据对比，如果相同，则验证成功！
避免有人直接入侵数据库，获取用户密码信息！

## Base64

<div style='font-size:20px;color:red'>base64 只是一种编码的方式，为了在网络中传输方便</div>

Base64是用文本表示二进制的编码方式，它使用4个字节的文本来表示3个字节的原始二进制数据。
它将二进制数据转换成一个如下所示64个可打印的字符组成的序列：

ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/

Base64的作用：

常用于网络传输，在某些基于文本的协议中，如果需要传输图片或者文件等，我们知道图片的存储格式是二进制数据，而非文本格式，我们必须将二进制的数据编码成文本格式，这时候Base64就派上用场了。
另外，由于某些系统中只能使用ASCII字符。Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法。
Base64编码之后往往比原始数据要大，所以它并没有压缩数据。
