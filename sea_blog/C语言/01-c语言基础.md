---
title: C语言基础
categories:
  - 编程
  - C语言
tags: 
  - c语言
abbrlink: 9ec06885
date: 2019-12-29 20:39:56
---



# C语言基础
对C语言基础只是的概括
目标文件 可执行文件 库 源文件
源文件指的是我们所编写的文件
```c
vi helloworld.c

#include <stdio.h>
int main(void){
    printf("hello world");
    return 0;
} 
```
以上xx.c就是我们的源文件

**在unix中**
编译c语言 cc xx.c 会在当前文件夹生成一个a.out的可执行文件  运行即可

整个流程就是用户输入代码生成源码文件 通过cc编译后生成可执行文件 运行输出内容
cc其实是一个命令，可以用man cc 查看  也可以用cc -v查看版本信息

**在linux中**
使用gcc编译c文件 
```bash
gcc -o hello helloworld.ca
```
运行
```bash
./hello
```



## C语言中指令函数语句
指令函数语句这些要分清楚,因为C语言中有些符号是共用的,如果不了解他在某个模式下所代表的意义,就会变得很混乱.比如在指针上,有一个`寻地址符号(*)`,在语句中使用它可以取到对应变量地址上的值,但是在声明过程中使用的时候,他仅仅代表变量的存储地址,因此这是有区别的

C语言规定每条语句都要以分号结尾。（就像任何好的规则一样，这条规则也有一个例外：


## 定义变量与输出变量
```c++
#include<stdio.h>
#include <math.h> // 数学工具头文件
// 以上是头文件

int main(){
	/*
		编写一些注释
		你可以选择多行注释
		也可以选择单行注释 //
	*/

	// 输出一些内容
	printf("hello world\a");
	
	// 定义一些变量
	char fred;  // 字符型
	int bob; // 整型
	float jimmy; // 浮点型
	double tom; // 浮点型
	char name,like; // 定义
	char str[] = "Hello, world.\n"; //创建数组

	
	printf("Profit: $%.2f\n", profit); //保留两位小数
	printf("%d",bob) // 输出整数
	return 0;

}
```
其中 
- %d是整数占位符
- %f是浮点型占位符
- %s是字符串型占位符
- %c是字符型占位符
- %p是变量的地址
- %u表示无符号10进制整型
- %lu表示输出无符号长整型整数 (long unsigned)


输入scanf
```c++
#include "library.h"
#include <stdio.h>
void hello(void) {
    char c = 's';
    printf("Hello, World!\n");
    printf("helloworld,%c",c);

}

void waitScanf(void){
    int i = 0;
    scanf("%d", &i);  // 等待输入一个int类型,并将值存储到i变量的存储地址上
	scanf("%f",&i) // 等待输入一个float类型,并将值存储到i变量的存储地址上
    printf("your input things is %d",i);
}


int main(void){
    hello();
    waitScanf();
    return 0;
}
```

## 宏定义
当程序中需要一些固定不变的变量的时候,我们称这些变量为常量
`#define`是预处理指令,当对程序进行编译的时候,预处理器会把每一个宏替换为其表示的值

```c++
#include <stdio.h>
#define  INCHES_PER_POUND 166  // 声明变量
#define   SCALE_FACTOR (5.0f / 9.0f) //声明表达式


int main(void){
    printf("this number is %d",INCHES_PER_POUND );
	celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;
	printf("this number is %f",celsius)
    return 0;
}
```


## 方法
```c
#include <stdio.h>
// 以上是头文件

// 不带参数的方法
void func()
{
	printf("hello wolrd \n");
	printf("i am a extra func out of the main\n");
}

// 带参数的方法
void PrintName(char name, int age)
{
	printf("myname is %c,my age is %d\n", name, age);
}

int main()
{

	func();
	printf("\n");
	PrintName('h',12);

	return 0;
}
```


## 全局变量与局部变量以及作用域
设计到全局与局部的变量时候，就要讲到作用域，作用域一般以{}为界限，{}内的变量有他自己的生命周期，即超过{}后生命周期自动结束，释放存储空间

局部变量在每次函数调用时分配存储空间，在每次函数返回时释放存储空间，作用域内的变量生命周期结束。
例如调用print_time(23, 59)时分配hour和minute两个变量的存储空间，在里面分别存上23和59，函数返回时释放它们的存储空间，下次再调用print_time(12, 20)时又分配hour和minute的存储空间，在里面分别存上12和20。

```c++

#include <stdio.h>
// 以上是头文件

int a = 1;
int b = 2;

int main()
{
	int c = 1;
	int d = 2;
	func(c,d);

	// func(1,2) 这里其实发生了一些事情，首先 a,b是全局变量，他们的生命周期是直到程序结束后停止，
	// 而 cd 的生命周期是func函数的生命周期，func函数嗲用结束之后，cd的生命周期结束
	// 在调用func函数的时候，传入了两个值，1和2   也就是c=1 d=2 ,此时c语言为c和d两个变量分配存储空间
	// 在他们各自的存储空间上存放了 1 ，2 两个变量的值
	// 函数结束之后，两个变量的存储空间消失，下次再调用方法的时候，重新分配给c d的新的存储空间
	
	return 0;

}

void func(int c, int d)
{
	printf(c + d);
}
```

与局部变量的概念相对的是全局变量（Global Variable），全局变量定义在所有的函数体之外，它们在程序开始运行时分配存储空间，在程序结束时释放存储空间，在任何函数中都可以访问全局变量.

## 流程控制
### if语句
```bash
if (i=0;i<=10;i++){
	printf("this id is %d",i)
}
else{
	printf("no this id")
}
```
### goto 语句
goto语句，实现无条件跳转。我们知道break只能跳出最内层的循环，如果在一个嵌套循环中遇到某个错误条件需要立即跳出最外层循环做出错处理，就可以用goto语句，例如：
```c++
for (...)
	for (...) {
		...
		if (出现错误条件)
			goto error;
	}
error:
	出错处理;
```

### 三目运算符
```c++
#include <stdio.h>

int main(){
▏ int a = 10;
▏ int b = 20;
▏ // 三目运算符 表达式 ？ a : b ;·
▏ // 首先先判断表达式返回的值，如果是true 则执行 a
▏ // 如果是flase 则执行b
▏ // res : 20
▏ int res = 0 ? a : b;
▏ printf("%d\n",res);
▏ return 0;
}
```


## 结构体
在编程语言中，最基本的、不可再分的数据类型称为基本类型（Primitive Type），例如整型、浮点型；根据语法规则由基本类型组合而成的类型称为复合类型（Compound Type），例如字符串是由很多字符组成的。有些场合下要把复合类型当作一个整体来用，而另外一些场合下需要分解组成这个复合类型的各种基本类型，复合类型的这种两面性为数据抽象（Data Abstraction）奠定了基础

用结构体表示复数
```c++
#include <stdio.h>

struct complex_struct
{
	int x, y;
};

// 声明结构体
int main()
{

	//1
	struct complex_struct z1;
	z1.x = 1;
	z1.y = 2;
	//2
	struct complex_struct z1 = {1, 2};

	return 0;
}
// 结构体方法
struct complex_struct add_complex(struct complex_struct z1, struct complex_struct z2)
{
	z1.x = z1.x + z2.x;
	z1.y = z1.y + z2.y;
	return z1;
}
```

### 结构体声明
结构体的声明有两种形式,一种是先创建模板,再声明变量,第二中是在创建模板的同时声明变量
```C++
//先创建模板
struct model {
	int number;
	char name[NAME_LEN+1]
	int on_hand;
}
// 声明变量
int main(){
	struct model model1;
}


// 在创建模板的同时,声明变量 
struct Model{
	int number;
	char chartext;
	int on_head;
} pat1 part2;

// 创建模板的同时,不声明模板 但是声明变量
struct {
    int numbers;
    int hello;
    int world;
} part1 

// 创建模板的同时,初始化变量
struct {
    int numbers;
    int hello;
    int world;
} part1 = {12,3,4};

struct Model {
    int numbers;
    int hello;
    int world;
} part2 = {12,3,4};

struct {
    int numbers;
    int hello;
    int world;
} part1 = {12,3,4},
  part2 = {1,2,3};
```
初始化式中的成员数可以少于它所初始化的结构，就像数组那样，任何“剩余的”成员都用0作为它的初始值。特别地，剩余的字符数组中的字节数为0，表示空字符串。

<font color='red'>出现的问题,根据C语言的规则，part1和part2不具有兼容的类型，因此不能把part1赋值给part2，反之亦然。而且，因为part1和part2的类型都没有名字，所以也就不能把它们用作函数调用的参数。</font>

为了克服这些困难，需要定义表示结构类型（而不是特定的结构变量）的名字。 C语言提供了两种命名结构的方法：可以声明“结构标记”，也可以使用typedef来定义类型名


```c++
//先创建模板
struct model {
	int number;
	char name[NAME_LEN+1]
	int on_hand;
}
// 声明变量
int main(){
	struct model model1;
}
```
类似这样的是创建了结构标记
``` C
struct {
    int numbers;
    int hello;
    int world;
} part1 = {12,3,4},
  part2 = {1,2,3};
```
这样的没有创建结构标记

### 结构体的存储顺序
结构体重的成员在内存中是按照声明的顺序存储的
![2020-06-22-10-25-56](http://img.noback.top/2020-06-22-10-25-56.png)
为了表示方便,抛开每一个成员所占据的字节大小,统一改为一个方块表示结构
![2020-06-22-10-26-58](http://img.noback.top/2020-06-22-10-26-58.png)

###  结构体作为参数和返回值
```c++
#include <math.h>

struct complex_struct {
	double x, y;
};

//抽象
double real_part(struct complex_struct z)
{
	return z.x;
}

double img_part(struct complex_struct z)
{
	return z.y;
}

double magnitude(struct complex_struct z)
{
	return sqrt(z.x * z.x + z.y * z.y);
}

double angle(struct complex_struct z)
{
	return atan2(z.y, z.x);
}
```
### 嵌套结构体
```c++
#include <stdio.h>

enum coordinate_type { RECTANGULAR = 1, POLAR };

struct in_test
{
	int id;
	char name;
};


struct  test
{
	enum coordinate_type t;
	int age;
	struct in_test in_tes;
};

int main(){
	//初始化嵌套结构体
	struct  test tes = { POLAR,12, 12, 'h' };
	printf("%d",tes.in_tes.id);
	
}
```



### 结构数组
创建结构数组
``` C++
struct part {
	char *country;
	int code;
}

const struct dialing_code country_codes[] =
{{"Argentina",            54}, {"Bangladesh",          880},
   {"Ukraine",             380}, {"United Kingdom",       44},
   {"United States",         1}, {"Vietnam",             84}};
//也就是在part这个结构体中存储了一个数组inventory
```


## 联合
像结构一样，联合（union）也是由一个或多个成员构成的，而且这些成员可能具有不同的类型。但是，编译器只为联合中最大的成员分配足够的内存空间。联合的成员在这个空间内彼此覆盖。这样的结果是，给一个成员赋予新值也会改变其他成员的值。
``` C
// 联合
union {
	int i;
	double d;

} u;
// 结构体
struct {
	int i ;
	double d;
} s;
```
![2020-06-22-11-07-05](http://img.noback.top/2020-06-22-11-07-05.png)
结构体的中的成员存储在不同的内存地址中,而联合中的成员存储在同一个内存地址中,该内存就是联合成员中最大的值.其他使用方式和结构体类似


## 数组
标量和聚合,标量是具保存单一数据项的能力,C语言也支持聚合变量,这类变量可以存储一组一组的数值.在C语言中一共有两种聚合类型 数组和结构.
一维数组如下
![2020-06-20-12-45-26](http://img.noback.top/2020-06-20-12-45-26.png)
多维数组如下
![2020-06-20-12-50-57](http://img.noback.top/2020-06-20-12-50-57.png)
另一种定义的形式
```c++
#include<stdio.h>
#define N 10

int main(void){
	int a[N]; // === int a[10]
	return 0

}
```

### 使用sizeof来确定数组的大小
运算符sizeof可以确定数组的大小（字节数）。如果数组a有10个整数，那么sizeof(a)通常为40（假定每个整数占4个字节）
另外sizeof还可以用来计算数组元素的大小比如`sizeof(a[10])`
用数组的大小除以数组元素的大小可以得到数组的长度：`sizeof(a) / sizeof(a[0])`


## 指针

### 指针变量
![2020-06-20-12-53-20](http://img.noback.top/2020-06-20-12-53-20.png)
在用指针变量p存储变量i的地址时，我们说p“指向”i,也就是说`指针就是地址，而指针变量就是存储地址的变量。`
为了说明指针变量p存储变量i的地址，将把p的内容显示为指向i的箭头
![2020-06-20-12-55-39](http://img.noback.top/2020-06-20-12-55-39.png)
于是我们把p叫做指针变量 变量i的存储地址为p p指向i  i的指针是p
```c++
//用程序表达如下
#include<stdio.h>

int main(){
	int *p ; //这里创建了一个指针p,但是他现在不指向任何地方,因为我们还没有给他任何地址
	// 声明指针变量是为指针留出空间，但是并没有把它指向对象
	int i = 10; // 创建一个基础变量,现在这个变量i有存储地址,在地址上存了一个10这个值
	p = &i; // 取i的地址复制给指针p  现在指针p所指向的地址就是变量i所存放数值10的地址
	// 使用间接寻址符,找到i的变量
	printf("%d\n",*p) //*p就是i的别名
	return 0;
}
```
### 取地址符与间接寻址运算符
`&`是取地址符,为了找到变量的地址，可以使用&（取地址）运算符。如果x是变量，那么&x就是x在内存中的地址。
C语言中`*`星号有很多用处,在声明语句中`int *p` 他用来声明指针
为了获得对指针所指向对象的访问，可以使用*（间接寻址）运算符,如果p是指针，那么*p表示p当前指向的对象

其实可以把`*`看成rust里面的解引用

```c++
#include <stdio.h>

int main(void){
    int *p; // 创建一个指针  p -> null
    int i = 10; //创建变量
    p = &i; // 将存储10的地址给p进行赋值
    printf("%d\n",*p); // 间接寻址 找到i的值 10

    printf("%p\n",&i); //res: 0x7ffee17e256c
    printf("%p\n",p); // res: 0x7ffee17e256c

    return 0;
}

```
指针p指向了变量i存储值得地址


### 指针赋值
![2020-06-20-13-19-16](http://img.noback.top/2020-06-20-13-19-16.png)
![2020-06-20-13-19-38](http://img.noback.top/2020-06-20-13-19-38.png)

## 指针

![2020-03-03-13-17-08](http://img.noback.top/2020-03-03-13-17-08.png)

&是取地址运算符（Address Operator），&i表示取变量i的地址，
int *pi = &i;表示定义一个指向int型的指针变量pi，并用i的地址来初始化pi。
我们讲过全局变量只能用常量表达式初始化，如果定义int p = i;就错了，因为i不是常量表达式，然而用i的地址来初始化一个指针却没有错，因为i的地址是在编译链接时能确定的，而不需要到运行时才知道，&i是常量表达式。
后面两行代码定义了一个字符型变量c和一个指向c的字符型指针pc，注意pi和pc虽然是不同类型的指针变量，但它们的内存单元都占4个字节，因为要保存32位的虚拟地址，同理，在64位平台上指针变量都占8个字节。

\*号是指针间接寻址运算符（Indirection Operator），*pi表示取指针pi所指向的变量的值，也称为Dereference操作，指针有时称为变量的引用（Reference），所以根据指针找到变量称为Dereference。

在rust里面有引用的概念，同样的&表示引用，*表示解引用

```c++
type *pi 表示指定某个type类型的指针变量pi,注意 pi是指针，指向内存地址， *pi是变量,也就是通过pi指向内存地址后获取的值
int *pi 表示指向int类型的指针变量pi
int i; &i 表示变量i的内存地址
int *pi = &i 表示将变量i的内存地址赋值给指向int类型的指针变量pi  // 也就是说pi 不完全等于i 但是pi变量指向的内存地址= 变量i指向的内存地址，有点抽象
```
```c++
#include<stdio.h>


int main(){

	int i = 5;

	int *pi = &i;  // 将变量i 的地址赋值给pi  -- > 他实际发生的内容是这样的
	// int *pi //创建整型指针  pi = &i 或者指针指向地址  // *pi 解指针 获得变量  
	// pi表示指向&i的地址指针
	// *pi 表示指向&i的地址指针的变量
	printf("%p\n",pi); //res: 0x7ffee226e988
	printf("%p\n",&i); //res: 0x7ffee226e988


	printf("%d\n",*pi); // res: 5
	printf("%d\n",i); // res: 5
	return 0;
}
```

## 指针高级用法
这里要设计数据结构结构的设计

### 动态分配内存
C语言支持动态存储分配，即在程序执行期间分配内存单元的能力。利用动态存储分配，可以设计出能根据需要扩大（和缩小）的数据结构。
C语言的数据结构通常是固定大小的。例如，一旦程序完成编译，数组元素的数量就固定了。（在C99中，变长数组（➤8.3节）的长度在运行时确定，但在数组的生命周期内仍然是固定长度的。）因为在编写程序时强制选择了大小，所以固定大小的数据结构可能会有问题。也就是说，在不修改程序并且再次编译程序的情况下无法改变数据结构的大小。
为了动态地分配存储空间，需要调用三种内存分配函数的一种，这些函数都是声明在`<stdlib.h>`头上传
- malloc 函数，分配内存块，但是不对内存块进行初始化   <font color='red'>常用</font>
- calloc 函数，分配内存块，并且对内存块进行清零 
- realloc 函数，调整先前的内存块大小

当为申请内存块而调用内存分配函数时，由于函数无法知道计划存储在内存块中的数据是什么类型的，所以它不能返回int类型、char类型等普通类型的指针。取而代之的，函数会返回void *类型的值。void *类型的值是“通用”指针，本质上它只是内存地址

### 空指针
当我们调用函数分配内存的时候，总存在这样的可能性，找不到满足的足够大的内存块，这时候函数会返回一个空指针(null pointer)
<font color='red'>空指针是不指向任何地方的指针</font>
这是一个区别于所有有效指针的特殊值。在把函数的返回值存储到指针变量中以后，需要判断该指针变量是否为空指针。
```c++
p = malloc(1000);
if ( p == NULL){
	pass
}
```
所有非空指针都为真，所以
```c++
if (p==NULL) => if (!p)
if (P!=NULL) => if (p)
```


### malloc 分配内存
```c++
void *malloc(size_t size)
// malloc函数分配size个字节的内存块，并且返回指向该内存块的指针
```
用malloc函数为字符串分配内存是很容易的，因为C语言保证char类型值恰需要一个字节的内存（换句话说，sizeof(char)的值为1）。为给n个字符的字符串分配内存空间，可以写成
```c++
p = malloc(n+1)  // 给空字符留了空间，并且该内存分配完毕后，返回一个char * 类型的指针
```
![2020-06-23-10-49-18](http://img.noback.top/2020-06-23-10-49-18.png)
![2020-06-23-10-49-30](http://img.noback.top/2020-06-23-10-49-30.png)

### 释放存储空间free
malloc函数和其他内存分配函数所获得的内存块都来自一个称为堆（heap）的存储池。过于频繁地调用这些函数（或者让这些函数申请大内存块）可能会耗尽堆，这会导致函数返回空指针。

![2020-06-23-10-53-50](http://img.noback.top/2020-06-23-10-53-50.png)

```c++
// 产生内存泄露的原因
p = malloc(....)  // 从堆上面产生一定数量的内存块给p  内存地址假设为0x123456
q = malloc(....)  // 从堆上面产生一定数量的内存块给q  内存地址假设为0xffffff
p = q // 将q指向的内存块地址赋值给p 于是p和q都指向了同一个内存块地址  也就是原先q所指向的地址0xffffff
// 于是p原先所指向的地址0x123456没有被自动释放，最后导致内存泄露

```

使用free函数释放内存，free接收一个`指向内存地址的指针` 包括空指针，但是如果是指向其他对象(数组元素或者变量的指针)，可能会出现未定义的行为
```c++
p = malloc(...)
q = malloc(...)
free(p) // 释放0x123456 也就是p所指向的内存地址
p = q  // 将q的内存地址赋值给p  qp指向同一个内存地址
// 内存不泄露
```

### 悬空指针
同样是上面释放内存的例子

```c++
p = malloc(...)
q = malloc(...)
free(p) // 释放0x123456 也就是p所指向的内存地址
p = q  // 将q的内存地址赋值给p  qp指向同一个内存地址
// 内存不泄露
```
如果上面没有对p进行内存地址的赋值，则会产生悬空指针p 这样的指针没有指向任何的内存地址


### 内存泄露导致的问题
内存泄漏会因为减少可用内存的数量从而降低计算机的性能。最终，在最糟糕的情况下，过多的可用内存被分配掉导致全部或部分设备停止正常工作，或者应用程序崩溃。

内存泄漏带来的后果可能是不严重的，有时甚至能够被常规的手段检测出来。在现代操作系统中，一个应用程序使用的常规内存在程序终止时被释放。这表示一个短暂运行的应用程序中的内存泄漏不会导致严重后果。

在以下情况，内存泄漏导致较严重的后果：

程序运行后置之不理，并且随着时间的流逝消耗越来越多的内存（比如服务器上的后台任务，尤其是嵌入式系统中的后台任务，这些任务可能被运行后很多年内都置之不理）；
新的内存被频繁地分配，比如当显示电脑游戏或动画视频画面时；
程序能够请求即使在程序终止之后也不会被释放的内存（比如共享内存）；
泄漏在操作系统内部发生；
泄漏在系统关键驱动中发生；

## 链表(Link List)

### 链表的结构
![2020-06-23-11-40-15](http://img.noback.top/2020-06-23-11-40-15.png)
链表的最后一个节点的第二部分是一个空指针，因为最后一个指针不指向任何一个节点
链表比数组更灵活，在插入和删除节点上更加容易 也就说允许链表根据需要扩大或者缩小


### 声明单节点类型
```c++
// 使用结构体创建一个单节点模板 不包括尾部
struct node {
	int value; //第一部分 值
	struct node *next // 第二部分 单节点的指针 名字叫做next  也就是
}

// 获取每一个节点的长度，动态分配内存

// 获取每个节点的长度
printf(sizeof(struct node))
// 动态分配节点的长度
new_node = malloc(sizeof(struct node))
// 将内容填充到new_node中去
(*new_node).value = 10;  // 该语句等于 new_node -> value = 10
```
![2020-06-24-10-30-33](http://img.noback.top/2020-06-24-10-30-33.png)


### 在链表头部开始插入结点
链表相对于数组来说，就是方便了结点的插入 ，他可以在表中的任何位置添加结点
```c++
struct node *first = NULL // 把first初始化为NULL表明链表初始化为空

// 将新结点指向首节点
new_node->next = first;
// 将first指向新节点
first = new_node;
```


### 结合来看
```c++
// 创建节点
struct node {
	int value;
	struct node *next;
}

// 创建一个新的结点
new_node = malloc(sizeof(struct node));

// 创建第一个结点
struct node *first = NULL ;

// 给新的结点赋值

new_node->value = 10;

// 给新的结点赋值下一个指向的地址 ,置空
new_node->next = first;

first = new_node;
new_node = malloc(sizeof(struct node));
new_node -> value = 20;
new_node -> next = first;
first = new_node;

```
![2020-06-24-10-52-46](http://img.noback.top/2020-06-24-10-52-46.png)




## 宏定义


### #ifndef, #define, #endif 作用
https://www.cnblogs.com/challenger-vip/p/3386819.html


### 宏定义的定义类型
宏定义的两种类型
- 变量式宏定义
即在代码头部通过宏定义的方式声明变量
宏定义名可以像变量一样在代码中使用
```c++
#define STR "hello, world"
#define number 2
```
- 函数式宏定义(Function-like Macro)
同变量式宏定义一样，函数式宏定义可以在代码中使用
```c++
#define MAX(a, b) ((a)>(b)?(a):(b))
```

```c++
#include<stdio.h>
#define MAX(a, b) ((a)>(b)?(a):(b))

int a[] = { 9, 3, 5, 2, 1, 0, 8, 7, 6, 4 };

int max(int n)
{
	 return n == 0 ? a[0] : MAX(a[n], max(n-1));
}

int main(void)
{
  int res = max(9);
  printf("%d",res);
  return 0;
}
```
<font color='red'>宏定义的形式与普通的函数方式有什么不同</font>

- 函数式宏定义的参数没有类型，预处理器只负责做形式上的替换，而不做参数类型检查，所以传参时要格外小心。
- 调用真正函数的代码和调用函数式宏定义的代码编译生成的指令不同。如果MAX是个真正的函数，那么它的函数体return a > b ? a : b;要编译生成指令，代码中出现的每次调用也要编译生成传参指令和call指令。而如果MAX是个函数式宏定义，这个宏定义本身倒不必编译生成指令，但是代码中出现的每次调用编译生成的指令都相当于一个函数体，而不是简单的几条传参指令和call指令。所以，使用函数式宏定义编译生成的目标文件会比较大。


尽管函数式宏定义和真正的函数相比有很多缺点，但只要小心使用还是会显著提高代码的执行效率，毕竟省去了分配和释放栈帧、传参、传返回值等一系列工作




## 字符串
从本质而言，C语言把字符串字面量作为字符数组来处理。当C语言编译器在程序中遇到长度为的字符串字面量时，它会为字符串字面量分配长度为的内存空间。这块内存空间将用来存储字符串字面量中的字符，以及一个用来标志字符串末尾的额外字符（空字符）。空字符是一个所有位都为0的字节，因此用转义序列\0来表示

![2020-06-20-13-26-31](http://img.noback.top/2020-06-20-13-26-31.png)

## c语言标准
###  C标准规定的转义字符
\'	单引号'（Single Quote或Apostrophe）
\"	双引号"
\?	问号?（Question Mark）
\\	反斜线\（Backslash）
\a	响铃（Alert或Bell）
\b	退格（Backspace）
\f	分页符（Form Feed）
\n	换行（Line Feed）
\r	回车（Carriage Return）
\t	水平制表符（Horizontal Tab）
\v	垂直制表符（Vertical Tab）

### c99中的关键字
auto  break  case  char  const  continue  default  do  double
else  enum  extern  float  for  goto  if  inline  int  long
register  restrict  return  short  signed  sizeof  static  struct  switch  typedef
union  unsigned  void  volatile  while  _Bool  _Complex  _Imaginary
## 错误
zsh: command not found: a.out
mac下无法执行cc编译后的文件
<font color='blue'>因为没有确定工作路径 运行./a.out就可以了</font>
