---
title: linux文件权限
categories:
  - linux
tags:
  - linux
abbrlink: af2754a4
date: 2020-02-16 23:41:43
---


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [文件权限](#文件权限)
  - [文件权限的表现方式](#文件权限的表现方式)
  - [改变文件权限和属性](#改变文件权限和属性)
  - [2.3文件权限识别的本质](#23文件权限识别的本质)
  - [2.4文件的扩展acl权限](#24文件的扩展acl权限)
  - [特殊权限](#特殊权限)
  - [其他的文章](#其他的文章)

<!-- /code_chunk_output -->
<!-- more -->
# 文件权限
除了用户权限以外，linux还具有文件的权限，在ugo权限管理中,大部分的文件基本交由user,group,other三种操作权限, 同时他们的权限分别为read write execute三种权限

## 文件权限的表现方式
当一个文件创建后，它具有读(r)、写(w)、执行(x)三种操作方式。UGO权限管理方式将访问文件的操作者简单分为三类：文件属主(u)、同组用户(g)与其他组用户(o)

举例： 现在我们创建一个文件，并且查看他的权限属性
```bash
touch a.txt && ls -al  
```
![](http://img.noback.top/blog/img20191106/linux.png)

"-"表示文件是普通类型，如d表示文件夹
"rw-" 表示文件属主对文件具有读和写的权限，但没有执行权限
"r--"  表示同组用户对文件只读，无写和执行权限
"r--" 表示其他组用户对文件只读，无写和执行权限
每一组权限都可以用二进制表示 每组“rwx”分别位"111" 十进制则是 7 
如"rw-" 二进制是110 十进制则是6，"r--" 二进制是100 十进制则是4

于是我们可以使用chmod+十进制来修改权限,
修改成三组用户可读可写可执行权限
```bash
chmod 777 a.txt && ls -al 
```
当然也可以通过另外一种形式
```bash
chmod ugo+rwx && ls -al  
```
除了上面使用chmod修改权限之外，我们还可以在文件创建的时候就完成他的权限规划
**文件创建掩码**
当我们创建一个文件夹的时候，你会发现他的权限是775，但是当你创建一个文件的时候，他的权限是664，其实是系统掩码的问题。每次创建文件夹的时候，就是777和掩码做与操作，创建文件的时候就是666与掩码做与操作

```bash
# 查看系统掩码
umask
# 修改系统掩码
umask u=, g=w, o=rwx
# 查看当前新建文件夹的权限
umask -S
```

## 改变文件权限和属性

**更改文件和目录的所属组 chgrp**
要求组本身在/etc/group中已经存在，对于已经有链接的文件来说，修改组的作用对象是链接的源文件，而不是链接文件本身
```bash
chgrp [option] group file # 修改组
chgrp [option] --reference=dest_file  file  # 修改file的组为dest_file的组
chgrp -R  group file # 递归修改,即文件夹下面的所有文件都改变群主
```

**修改文件所有者 chown**
```bash
chown -R 账号  文件或目录
chown -R 账号:群组 文件或目录
chown 账号.群组 文件
-R 递归传递，同chgrp
```
修改文件所有者和所属组,对于链接文件，chown不会直接去修改源文件，而是修改当前文件


**修改文件属性和权限**
chmod 有两种修改的形式
第一种使用数字来修改 分别对应的是 6 4 2 r w x
```bash
chmod 777  xxx.txt
chmod rwx  
```
另外一种是用ugo+rwx来修改，其中 +（加入） -（除去） =（设置）
```bash
chmod ugo=rwxrwxrwx xxx.txt 
```


## 2.3文件权限识别的本质
首先，权限的元数据放在inode中，严格地说是放在inode table中，因为每个块组的所有inode组成一个inode table。在inode table中使用一列来存放数字型的权限，比如某文件的权限为644。每次用户要对文件进行操作时系统都会先查看权限，确认该用户是否有对应的权限来执行操作。当然，inode table一般都已经加载到内存中，所以每次查询权限的资源消耗是非常小的

## 2.4文件的扩展acl权限
在计算机相关领域，所有的ACL(access control list)都表示访问控制列表。
文件的owner/group/others的权限就是一种ACL，它们是基本的ACL。很多时候，只通过这3个权限位是无法完全合理设置权限问题的，例如如何仅设置某单个用户具有什么权限。这时候需要使用扩展ACL。
扩展ACL是一种特殊权限，它是文件系统上功能，用于解决所有者、所属组和其他这三个权限位无法合理设置单个用户权限的问题。所以，扩展ACL可以针对单一使用者，单一档案或目录里的默认权限进行r,w,x的权限规范。
需要明确的是，扩展ACL是文件系统上的功能，且工作在内核，默认在ext4/xfs上都已开启。

**查看文件系统是否开启acl功能**
不同的文件系统查看的方法不一样，ext的文件系统
```bash
dumpe2fs -h /dev/sda2 | grep -i acl
dumpe2fs 1.41.12 (17-May-2010)
Default mount options:    user_xattr acl

# 如果没有，则是
[root@test-ceph ~]# dumpe2fs -h /dev/sda1 | grep -i acl
dumpe2fs 1.42.9 (28-Dec-2013)
dumpe2fs: Bad magic number in super-block 当尝试打开 /dev/sda1 
```
对于xfs文件系统来说，默认会开启acl，但是你也可以用dmesg查看
```bash
dmesg | grep -i acl 
[root@test-ceph ~]# dmesg | grep -i acl
[    1.533401] systemd[1]: systemd 219 running in system mode. (+PAM +AUDIT +SELINUX +IMA -APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 -SECCOMP +BLKID +ELFUTILS +KMOD +IDN)
[    2.993939] SGI XFS with ACLs, security attributes, no debug enabled
```
开启ACL功能后，不代表就使用ACL功能。是否使用该功能，不同文件系统控制方法不一样，对于ext家族来说，通过mount挂载选项来控制，而对于xfs文件系统，<font color='red'>mount命令根本不支持acl参数(xfs文件系统如何关闭或启用）--->暂不知道</font>

**设置和查看acl**
设定acl --> setfacl
```bash
setfacl [option] u:[user]:[rwx] 目录文件 
setfacl [option] g:[组列表]:[rwx] 目录文件
``` 

-m 设定acl权限
-x：删除指定的ACL权限，可以指定用户、组和文件来删除(remove)
-M：写了ACL条目的文件，将从此文件中读取ACL条目，需要配合-m，所以-M指定的是modify file
-X：写了ACL条目的文件，将从此文件中读取ACL条目，需要配合-x，所以-X指定的是remove file
-n：不重置mask
-b：删除所有的ACL权限
-d：设定默认ACL权限，只对目录有效，设置后子目录(文件)继承默认ACL，只对未来文件 有效
-k：删除默认ACL权限
-R：递归设定ACL权限，只对目录有效，只对已有文件有效

获取acl --> getfacl
```bash
getfacl filename
```

**acl中的mask**
设置mask后会将mask权限与已有的acl权限进行与计算，计算后的结果会成为新的ACL权限。
比如之前的hzj用户有rwx的权限，设置mask  r-- 后你会发现hzj用户只有可读的权限  做与操作
如果一个文件有多个用户需要设置权限，这个时候每次授权都会重置mask，这个时候我们可以用-n来避免
```bash
# 设置mask
getfacl -m m:[rwx] 目录/文件名
# 限制mask变更
setfacl -n -m u:hzj:rwx tt.txt
```
**设置递归和默认acl权限**
递归ACL权限只对目录里已有文件有效，默认权限只对未来目录里的文件有效。
```bash
# 递归ACL
setfacl -m u:name:[rwx] -R 目录名 
# 默认acl
setfacl -m d:u:name:[rwx] 目录名
```
**删除acl**
```bash
setfacl -x u:name file # 删除指定用户ACL
setfacl -x g:gname file # 删除指定组名acl
setfacl -b file # 指定文件删除acl
```


## 特殊权限    

**文件隐藏属性**
http://www.ha97.com/5172.html
```bash
chattr [+ - = ][ai] 文件或目录 
```
设置了a参数时，文件中将只能增加内容，不能删除数据，且不能打开文件进行任何编辑，哪怕是追加内容也不可以，所以像sed等需要打开文件的再写入数据的工具也无法操作成功。文件也不能被删除。只有root才能设置。
设置了i参数时，文件将被锁定，不能向其中增删改内容，也不能删除修改文件等各种动作。只有root才能设置。可以将其理解为设置了i后，文件将是永恒不变的了，谁都不能动它。


对/etc/shadow文件设置i属性，任何用户包括root将不能修改密码，而且也不能创建用户。
```bash
# 添加
chattr +i /etc/shadow 
# 删除
chattr -i /etc/shadow
```

**suid/sgid/sbit**


## 其他的文章
acl权限 https://www.cnblogs.com/ysocean/p/7801329.html
linux文件权限 https://www.cnblogs.com/zoulongbin/p/7263267.html
linux权限管理https://www.cnblogs.com/franknihao/p/7346771.html